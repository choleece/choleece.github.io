<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="choleece&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="choleece">
<meta property="og:url" content="https://www.choleece.cn/index.html">
<meta property="og:site_name" content="choleece">
<meta property="og:description" content="choleece&apos;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="choleece">
<meta name="twitter:description" content="choleece&apos;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.choleece.cn/"/>





  <title>choleece</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">choleece</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">blog</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/08/01/Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/01/Map/" itemprop="url">Map  相关知识点</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T20:38:59+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章，我们就来介绍下关于Map的一些知识点，Map作为一个Key-Value形式的集合，在平时的开发中，用得相对还是比较多的。</p>
<p>项目中，用得最多的，应当还是属HashMap。下面我们就从HashMap来开始了解Map相关的实现。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>查看源码，我们直到，HashMap的底层实现原理是基于数组 + 链表组成的，由于本人刚接触的是JDK1.8，所以直接从JDK1.8，开始介绍HashMap的常用方法及其实现，从网上我们能了解到JDK1.7和JDK1.8的实现还是有一些不一样的，如有兴趣的，可以看看<a href="https://mp.weixin.qq.com/s/fZRPogkkUfBnhbZQB5r-uw" target="_blank" rel="noopener">这篇文章</a></p>
<p>首先我们来看下HashMap的类继承关系，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>AbstractMap的类继承关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractMap&lt;&gt; implements Map&lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到如上的代码，有人可能有这样的疑惑（反正我是有），为什么HashMap继承了AbstractMap，它为何又要去重新实现一遍Map呢？后来，去搜了一下，<a href="https://blog.csdn.net/zhangzl1012/article/details/73521987" target="_blank" rel="noopener">大家都是这么说的</a>,是这个HashMap的作者Josh Bloch的一个失误，<a href="https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete" target="_blank" rel="noopener">最终的答案出处在这</a></p>
<p>由上我们可以看到，HashMap继承AbstractMap，那么HashMap肯定拥有Map所拥有的方法，以下是HashMap比较常用的方法：</p>
<table>
<thead>
<tr>
<th>方法描述</th>
<th>方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td>从Map中移除所有的映射关系</td>
<td>clear()</td>
</tr>
<tr>
<td>判断Map中是否包含某个Key</td>
<td>containsKey()</td>
</tr>
<tr>
<td>判断Map中是否包含某个Value</td>
<td>containsValue()</td>
</tr>
<tr>
<td>返回此Map中所有的映射关系Set视图</td>
<td>Set<map.entry> entrySet()</map.entry></td>
</tr>
<tr>
<td><strong>返回指定Key对应的Value</strong></td>
<td><strong>get(Key key)</strong></td>
</tr>
<tr>
<td>返回所有Key对应的Key Set视图</td>
<td>keySet()</td>
</tr>
<tr>
<td>判断此映射是否未包含映射关系</td>
<td>isEmpty()</td>
</tr>
<tr>
<td><strong>将指定的Key,Value存入到Map中</strong></td>
<td><strong>put(Key key, V v)</strong></td>
</tr>
<tr>
<td>放入一个Map集合</td>
<td>putAll(Map map)</td>
</tr>
<tr>
<td>如果存在一个键值对Key-Value，则将其移除</td>
<td>remove(Key key)</td>
</tr>
<tr>
<td>返回Map中键值对的个数</td>
<td>size()</td>
</tr>
<tr>
<td>返回Map中Value的Collection的视图</td>
<td>values()</td>
</tr>
<tr>
<td>移除特定Key且特定Value的映射关系</td>
<td>remove(K k, V v)</td>
</tr>
<tr>
<td>替换掉某一对应Key的值</td>
<td>replace(K k, V v)</td>
</tr>
<tr>
<td>用新值替换掉Key和Value都对应的值</td>
<td>replace(K k, OldValue old, NewValue new)</td>
</tr>
</tbody>
</table>
<p>表中标记的，可能是HashMap使用频率最高的两个方法，下面我们着重搞清除这两个方法是如何实现的，首先我们来看一下HashMap的几个重要的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">  // 系统默认的数组容量，默认大小为16</span><br><span class="line">  static final int DEFAULT_TABLE_CAPACITY = 1 &lt;&lt; 4;</span><br><span class="line">  // 系统默认数组的最大容量，最大容量为2的30次</span><br><span class="line">  static final int MAXMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">  // 系统默认的负载因子，默认大小为0.75【负载因子的作用是指扩容的时机，当threshod &gt; capacity * loadFactor时，Map需要做Resize处理，后边的源码分析的时候我们会看到】</span><br><span class="line">  static final float DEFAULT_LOAD_fACTOR = 0.75f;</span><br><span class="line">  // 将链表变成红黑树的链表长度的节点数（红黑树JDK1.7和JDK1.8的HashMap两个实现不同的地方，当链表长度很长的时候，HashMap的查询效率会变得很低O(n)，在红黑树里，查询效率会变成O(lgn)）</span><br><span class="line">  static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">  // 红黑树回退回链表的节点数</span><br><span class="line">  static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"></span><br><span class="line">  // HashMap内部映射关系的存储节点</span><br><span class="line">  static class Node&lt;K,V&gt; implements Map.Entry &#123;</span><br><span class="line">    // 存放Key的hash值</span><br><span class="line">    final int hash;</span><br><span class="line">    // 存放Key</span><br><span class="line">    final K key;</span><br><span class="line">    // 存放Value</span><br><span class="line">    V value;</span><br><span class="line">    // 指向下一个节点</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // HashMap的底层数组，‘每一个’数组的位值上存放的是一个链表或者树</span><br><span class="line">  transient Node&lt;K,V&gt;[] table;</span><br><span class="line">  // HashMap存放键值对的个数</span><br><span class="line">  transient int size;</span><br><span class="line">  // 记录HashMap被修改的次数，此处主要用在迭代的时候，后面我们会发现，其实HashMap不是线程安全的，为了实现&quot;fail-fast&quot;(快速失败)，就是在迭代的过程中，如果有某一线程修改了HashMap，则会出现和当前线程不一致的修改次数，迭代器会立马感知到，并且立刻抛出ConcurrentModificationException，而不是等迭代器完成后才告诉已经出错。这就是fail-fast机制。</span><br><span class="line">  transient int modCount;</span><br><span class="line">  // table需要resize的阈值。其大小为capacity * loadFactor，其中，capacity是大于等于传进来的initCapacity最小的2的幂指数，比如，initCapacity=3,则capacity=4</span><br><span class="line">  int threshold;</span><br><span class="line">  // HashMap 的负载因子，其大小可以根据实际情况自己调整，它也是组成table 去resize的一个因素之一。太大会造成table占的太满，链表太长；太小会导致table占用稀疏，浪费空间，一般用默认的就好</span><br><span class="line">  final float loadFactor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>好了，关于HashMap几个比较重要的参数已经介绍完了，下面我们重点来看看HashMap比较常用的两个函数的实现，put(K k, V v)、get(K e)；跟着这两个函数的源码，去看看HashMap的具体实现是什么样的</p>
<p>首先，我们来看看put方法，先把源码贴出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">  return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们接着一行一行分析HashMap的put过程：</p>
<p>首先会对Key进行hash，也就是执行hash函数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果键值为空，则直接返回0，如果键值不为空，则返回key的hashCode，无符号右移16位<br>当table为空的时候，我们会对table进行resize()，resize()的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    // 如果table为空或者长度为0，旧table的容量为0或者旧table的长度</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    // 如果原有table的长度不为0</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 判断原有table的大小是否大于等于最大值，如果是，将需要resize的阈值赋值为Integer的最大值，并返回原有table</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果原有table的容量 * 2 小于最大容量且大于16，则要对table进行扩容，扩容的大小为原table.length * 2</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当table为空或者length为0的时候，会执行resize()方法，然后返回一个新的table，再判断new table的长度 - 1 &amp; hash值，当作table的下标，这里有个取巧的地方，前边我们说过，数组的长度一定是2的幂，所以n - 1的二进制全部都是1，然后再与hash取 &amp; ，则只翻转0位即可，相比%的效率要高，这可能就是长度为什么要取2的幂的原因吧。我们看到，当table[(n-1)&amp;hash] == null时，代表数组相应位置的节点为空，则此时放入一个节点到数组里来当第一个树；然后我们接着观察，数组相应位置节点不为空，则判断，如果两者hash值相等且key相等（此处的key相等，可以是==，或者equals），则数组相应位置的node与当前需要put的值重复;如果数组相应位置的节点是一个树节点，则将待插入的节点按照树节点的插入方式插入；否则一直去遍历链表，如果key值重复，则什么也不操作，退出返回oldVaue。如果不是重复的，将数放到插入到链表的最后，插入后，判断链表长度是否到达散列成红黑数的阈值，如果到达，则将此链表散列成红黑树。<strong>红黑数的阈值-1</strong>，是为了去掉数组开头的那个值。</p>
<p>接着，我们再来看看get方法，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    // 判断是table是否为不为空，且长度 &gt; 0，且数组位置的第一个元素不为空</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">          // 检查数组的第一个元素key是否相等，如果相等，返回第一个</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，判断table是否不为空，且table的长度 &gt; 0，且数组的index的位置的元素不为空，如果条件满足，则接着往下找，否则返回空；接着检查数组的第一个元素key是否相等，如果相等，返回第一个；如果不想等，则接着链表往下找，如果节点是数类型的，则按照树类型的方法来查找节点，如果是链表类型的，则遍历整条链表，直到找到为止，如果，找不到，则返回空。</p>
<h4 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h4><ol>
<li>遍历HashMap的键值对</li>
</ol>
<p>第一步：利用map.entrySet 获取键值对的集合<br>第二步：利用第一步得到的集合，通过iterator进行遍历</p>
<ol>
<li>遍历HashMap的键</li>
</ol>
<p>第一步：利用map.keySet获取键的集合<br>第二步：利用第一步得到的集合，通过iterator进行遍历</p>
<ol>
<li>遍历HashMap的值</li>
</ol>
<p>第一步：利用map.values获取值的集合<br>第二步：利用第一步得到的集合，通过iterator进行遍历</p>
<p><strong>注意：</strong><br>  判断Key值相等的条件是hash值相等，且key == 或者equals返回true<br>  判断Value相等只虚equals为true即可<br>  HashMap允许键值对都为null</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/07/25/collections/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/collections/" itemprop="url">collections Java 集合内容</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T23:39:54+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java-集合内容"><a href="#Java-集合内容" class="headerlink" title="Java 集合内容"></a>Java 集合内容</h3><p>集合在Java里大致分为两种形式，一个是存储单个对象的，一个是以Key-Value的形式存在的，存储单个对象的对应的是Collection那一支，存储Key-Value的是对应的Map那一支。Collection和Map都是顶级接口。下面这篇文章就开始介绍Collection和Map这两个顶级接口下的内容。</p>
<h4 id="Java集合和数组的区别："><a href="#Java集合和数组的区别：" class="headerlink" title="Java集合和数组的区别："></a>Java集合和数组的区别：</h4><ol>
<li>数组长度在初始化时指定，意味着之只能保存定长的数据。而集合可以保存数量上不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对key-value）。</li>
<li>数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。<br><a href="https://www.jianshu.com/p/589d58033841" target="_blank" rel="noopener">以上区别出处</a></li>
</ol>
<h4 id="结合相关整体结构图"><a href="#结合相关整体结构图" class="headerlink" title="结合相关整体结构图"></a>结合相关整体结构图</h4><p><img src="/2018/07/25/collections/collection_total.jpg" title="集合整体结构图"><a href="https://www.jianshu.com/p/816d41accd37" target="_blank" rel="noopener">图出处</a></p>
<h4 id="常用集合结构图"><a href="#常用集合结构图" class="headerlink" title="常用集合结构图"></a>常用集合结构图</h4><p><a href="https://blog.csdn.net/sdhgood/article/details/38849477" target="_blank" rel="noopener">图出处</a></p>
<h4 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h4><p>Collection接口继承了Iterable接口，表明Collection是可以迭代的，关于Iterable的知识，可以查看<a href="https://choleece.github.io/2018/07/25/iterator/" target="_blank" rel="noopener">Iterable</a></p>
<p>以下是集合抽象出来的一些公共方法：</p>
<table>
<thead>
<tr>
<th>方法描述</th>
<th>方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加一个元素</td>
<td>add(E e)</td>
</tr>
<tr>
<td>添加一个集合</td>
<td>addAll(Collection c)</td>
</tr>
<tr>
<td>清除所有的元素</td>
<td>clear()</td>
</tr>
<tr>
<td>判断是否存在</td>
<td>contains()</td>
</tr>
<tr>
<td>判断是否存在特定集合的所有元素</td>
<td>containsAll(Collection c)</td>
</tr>
<tr>
<td>判断是否相等</td>
<td>equals(Object o)</td>
</tr>
<tr>
<td>判断集合是否为空</td>
<td>isEmpty()</td>
</tr>
<tr>
<td>移除一个元素</td>
<td>remove(Object o)</td>
</tr>
<tr>
<td>移除一个集合里的元素</td>
<td>removeAll()</td>
</tr>
<tr>
<td>取与一个集合的交集</td>
<td>retainAll(Collection c)</td>
</tr>
<tr>
<td>返回集合里元素的个数</td>
<td>size()</td>
</tr>
<tr>
<td>将集合元素返回一个数组</td>
<td>toArray()</td>
</tr>
<tr>
<td>将集合元素返回一个数组</td>
<td>toArray(T[] t)</td>
</tr>
</tbody>
</table>
<p>说明：关于toArray(T[] t)，如果t.length &gt; collection.size()，那么t多余的部分将置为空，此时调用返回数组的index &gt; collection.size()的话，会出现NPE</p>
<p>Collection下比较常用的有接口有List, Set, QUeue，这三个接口是直接继承顶级接口的。</p>
<h5 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h5><p>List集合代表一个元素<strong>有序，可重复的集合，集合中每个元素都有其对应的顺序索引</strong>。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。List集合默认元素的添加顺序设置元素的索引。</p>
<p>查看List源码，可以看到，List是直接继承集合的，是属于Collection的一个子接口，因此，List可以使用Collection里所有的方法。且List是有序的几个，因此List集合里增加里一些根据索引来操作集合元素的方法。同时List也提供一个比较特殊的迭代器，ListIterator，关于ListIterator的知识，可以查看<a href="https://choleece.github.io/2018/07/25/iterator/" target="_blank" rel="noopener">ListIterator</a></p>
<p>以下是List抽象出来的一些公共方法：</p>
<table>
<thead>
<tr>
<th>方法描述</th>
<th>方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td>在指定位置添加元素</td>
<td>add(int index, E e)</td>
</tr>
<tr>
<td>在指定位置添加集合</td>
<td>addAll(int index, E e)</td>
</tr>
<tr>
<td>获取指定位置的元素</td>
<td>get(int index)</td>
</tr>
<tr>
<td>返回某一元素的最后一个索引</td>
<td>lastIndexOf(Object o)</td>
</tr>
<tr>
<td>返回某一位置往后的列表的ListIterator</td>
<td>listIterator(int index)</td>
</tr>
<tr>
<td>替换某一位置的元素</td>
<td>set(int index, E e)</td>
</tr>
<tr>
<td>排序</td>
<td>sort()</td>
</tr>
<tr>
<td>返回某一子列表</td>
<td>subList(int fromIndex, int toIndex)</td>
</tr>
</tbody>
</table>
<h5 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h5><p>Set集合代表一个<strong>元素不重复的集合</strong>。继承Collection，其方法大致与Collection大致相同，Set允许<strong>最多有一个空值</strong>。</p>
<h5 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h5><p>Queue<strong>模拟</strong>队列这种数据结构，队列在数据结构里通常是指”FIFO”的容器，Queue基本上不允许有对坐标的操作，以下为队列的几个基本方法。</p>
<table>
<thead>
<tr>
<th>方法描述</th>
<th>方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取头部数据，并且不删除队头</td>
<td>element()</td>
</tr>
<tr>
<td>将指定的元素插入此队列，在成功时返回true，如果当前没有可用的空间，则抛出IllegalStateException</td>
<td>add(E e)</td>
</tr>
<tr>
<td>将指定的元素插入此队列，当使用容量有限制的队列时，此方法通常要优于add(E e)，后者可能无法插入元素，而只是抛出一个异常</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>获取但<strong>不移除</strong>此队列的头, 如果队列为空，则返回null</td>
<td>peek()</td>
</tr>
<tr>
<td>获取并<strong>移除</strong>此队列的头，如果队列唯恐，则返回null</td>
<td>poll()</td>
</tr>
<tr>
<td>获取并移除此队列的头</td>
<td>remove()</td>
</tr>
</tbody>
</table>
<h4 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h4><p>Map是一个顶级接口。Map保存具有映射关系的数据，即key-value键值对的形式。一个Map不能包含一个重复的Key，一个Key值最多对应一个Value。Map接口提供了三种集合试图，包括一个返回<strong>key</strong>的set，一个返回<strong>value</strong>的Collection，还有一个返回<strong>键值对Key-Value</strong>的Set。从Map中取出数据时，只要给出特定的Key，就能取出对应的Value。</p>
<p>以下是Map抽象出来的一些公共方法：</p>
<table>
<thead>
<tr>
<th>方法描述</th>
<th>方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td>从Map中移除所有的映射关系</td>
<td>clear()</td>
</tr>
<tr>
<td>判断Map中是否包含某个Key</td>
<td>containsKey()</td>
</tr>
<tr>
<td>判断Map中是否包含某个Value</td>
<td>containsValue()</td>
</tr>
<tr>
<td>返回此Map中所有的映射关系Set视图</td>
<td>Set<map.entry> entrySet()</map.entry></td>
</tr>
<tr>
<td>返回指定Key对应的Value</td>
<td>get(Key key)</td>
</tr>
<tr>
<td>返回所有Key对应的Key Set视图</td>
<td>keySet()</td>
</tr>
<tr>
<td>判断此映射是否未包含映射关系</td>
<td>isEmpty()</td>
</tr>
<tr>
<td>将指定的Key,Value存入到Map中</td>
<td>put(Key key, V v)</td>
</tr>
<tr>
<td>放入一个Map集合</td>
<td>putAll(Map map)</td>
</tr>
<tr>
<td>如果存在一个键值对Key-Value，则将其移除</td>
<td>remove(Key key)</td>
</tr>
<tr>
<td>返回Map中键值对的个数</td>
<td>size()</td>
</tr>
<tr>
<td>返回Map中Value的Collection的视图</td>
<td>values()</td>
</tr>
</tbody>
</table>
<p><a href="https://www.jianshu.com/p/589d58033841" target="_blank" rel="noopener">文章参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/07/25/iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/iterator/" itemprop="url">iterator</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T23:35:57+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Iterator-和-Iterable-迭代器"><a href="#Iterator-和-Iterable-迭代器" class="headerlink" title="Iterator 和 Iterable 迭代器"></a>Iterator 和 Iterable 迭代器</h3><p>首先看名字我们就大致能发现这两个东西的不同，一个是迭代器，一个是可迭代的，下面我们来了解下这两个东西</p>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>Iterator是一个接口，部分源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">    // 判断集合中是否还有元素，如果还有元素可以迭代，就返回true</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    // 返回迭代的下一个原色，注意：如果没有下一个元素时，调用next()会抛出NoSuchElementException</span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">    // 从迭代器指向的结合中移除地带其返回的最后一个元素，这个也是迭代器常用的方法，在迭代的过程中去掉删除掉某个元素</span><br><span class="line">    // 从这个方法可以看出，interface的方法是可以有方法体的（从JDK1.8后开始支持，方法前必须用static 或者 default修饰，）</span><br><span class="line">    default void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;remove&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器的出现，是为了更好的处理集合中的元素，屏蔽集合的内部细节。</p>
<p>迭代器遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List list = new ArrayList();</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(2);</span><br><span class="line">    list.add(3);</span><br><span class="line">    list.add(4);</span><br><span class="line">    list.add(5);</span><br><span class="line">    list.add(6);</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子为迭代器简单的遍历过程，下面我们来看下删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List list = new ArrayList();</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(2);</span><br><span class="line">    list.add(3);</span><br><span class="line">    list.add(4);</span><br><span class="line">    list.add(5);</span><br><span class="line">    list.add(6);</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">        itetator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法会正常执行，执行完后，list会变成空集合，再看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List list = new ArrayList();</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(2);</span><br><span class="line">    list.add(3);</span><br><span class="line">    list.add(4);</span><br><span class="line">    list.add(5);</span><br><span class="line">    list.add(6);</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        itetator.remove();</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会抛出IllegalStateException，调用remove之前没有调用next是不合法的。</p>
<h4 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h4><p>Iterable也是一个接口，表明继承了Iterable的类是可迭代的，并且支持增强for循环</p>
<p>Iterable的部分源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承了Iterable的类是可以返回一个Iterator迭代器的，也就包含了Iterator的操作行为。</p>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>我们查看ListIterator的源码可以看到，ListIterator是继承Iterator的，所以Iterator有的功能ListIterator都有，ListIterator的部分源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">    boolean hasPrevious();</span><br><span class="line"></span><br><span class="line">    E previous();</span><br><span class="line"></span><br><span class="line">    int nextIndex();</span><br><span class="line"></span><br><span class="line">    int previousIndex();</span><br><span class="line"></span><br><span class="line">    void remove();</span><br><span class="line"></span><br><span class="line">    void set(E e);</span><br><span class="line"></span><br><span class="line">    void add(E e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从源码可以看到，ListIterator里同样也有next()，hasNext()，remove()方法，但是同时，我们可以看到ListIterator也有previous()，hasPrevious()等方法，所以我们可以得知Iterator是一个单向的迭代，而ListIterator是一个双向的。<br>另外，Iterator还有其他的几个方法，我们下边来分别介绍下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List list = new ArrayList();</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(2);</span><br><span class="line">    list.add(3);</span><br><span class="line">    list.add(4);</span><br><span class="line">    list.add(5);</span><br><span class="line">    list.add(6);</span><br><span class="line"></span><br><span class="line">    ListIterator li = list.listIterator();</span><br><span class="line"></span><br><span class="line">    System.out.println(li.previousIndex());</span><br><span class="line"></span><br><span class="line">    // 向后遍历</span><br><span class="line">    while (li.hasNext()) &#123;</span><br><span class="line">        System.out.println(li.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;向后遍历完，接着执行set 0&quot;);</span><br><span class="line">    li.set(0);</span><br><span class="line">    System.out.println(&quot;set 0 完毕，执行next index&quot;);</span><br><span class="line">    System.out.println(li.nextIndex());</span><br><span class="line">    System.out.println(&quot;next index 完毕，执行add&quot;);</span><br><span class="line">    li.add(7);</span><br><span class="line">    System.out.println(&quot;add 0 完毕，执行next index&quot;);</span><br><span class="line">    System.out.println(li.nextIndex());</span><br><span class="line">    System.out.println(&quot;next index 完毕，执行previous index&quot;);</span><br><span class="line">    System.out.println(li.previousIndex());</span><br><span class="line">    while (li.hasPrevious()) &#123;</span><br><span class="line">        System.out.println(li.previous());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述结果，会发现，在刚开始的时候，执行previousIndex，返回的是-1,此时迭代“指针”还处于初始位置，如果此时执行set操作会报错，在后边的set方法中，set进去的值会替换掉当前位置的值，如果是add，则是添加一个值到list当中去</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/07/21/maven-dependency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/21/maven-dependency/" itemprop="url">关于构建maven多模块 dependency dependencyManagment 的用法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-21T12:18:14+08:00">
                2018-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="dependency-dependencyManagment-在maven多模块中的使用"><a href="#dependency-dependencyManagment-在maven多模块中的使用" class="headerlink" title="dependency dependencyManagment 在maven多模块中的使用"></a>dependency dependencyManagment 在maven多模块中的使用</h3><p>dependency在单module中用法，在这就不再赘述，网上有很多资源介绍dependency的。</p>
<p>dependencyManagment 应用场景</p>
<p>当我们的项目模块（即有多个module）的时候，各模块中间会有很多的基础包是重复的，为了项目的正确运行，必须让所有的子项目使用依赖项的统一版本，必须确保应用的各个项目的依赖项和版本一直，才能保证测试和发布的是相同的结果。</p>
<p>在顶层的pom文件中，我们会抽象出一些各子模块会公用的jar包，这个时候我们用dependencyManagement来管理，让子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，知道找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中制定的版本号。</p>
<p>下面，我们将举例子来说明这个问题：<br>项目结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zheng-boot</span><br><span class="line">         |</span><br><span class="line">          zheng-boot-common</span><br><span class="line">         |</span><br><span class="line">          zheng-boot-cms</span><br><span class="line">                        |</span><br><span class="line">                         zheng-boot-cms-admin</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个项目大概有三层，zheng-boot作为顶级project，zheng-boot下又有zheng-boot-common 和 zheng-boot-cms两个模块，然后zheng-boot-cms下边又有zheng-boot-cms-admin一个子模块。</p>
<p>先将各项目的pom.xml的代码贴出来，给大家看看，然后照着pom.xml给大家讲解</p>
<p>zheng-boot的pom.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- zheng-boot pom.xml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;cn.choleece&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;zheng-boot&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">      &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">      &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">      &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">      &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">      &lt;spring.version&gt;5.0.7.RELEASE&lt;/spring.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;modules&gt;</span><br><span class="line">      &lt;module&gt;zheng-boot-common&lt;/module&gt;</span><br><span class="line">      &lt;module&gt;zheng-boot-cms&lt;/module&gt;</span><br><span class="line">  &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencyManagement&gt;</span><br><span class="line">      &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;cn.choleece.zhengboot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;zheng-boot-common&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;cn.choleece.zhengboot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;zheng-boot-cms&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/dependencies&gt;</span><br><span class="line">  &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>zheng-boot-common的pom.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  &lt;-- zheng-boot-common pom.xml --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;zheng-boot&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;cn.choleece&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;cn.choleece.zhengboot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zheng-boot-common&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--generate ids using snowflake--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.relops&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;snowflake&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>zheng-boot-cms的pom.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">  &lt;-- zheng-boot-cms pom.xml --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;zheng-boot&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;cn.choleece&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;cn.choleece.zhengboot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zheng-boot-cms&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;zheng-boot-cms&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;zheng-boot-cms-admin&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.choleece.zhengboot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zheng-boot-common&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.2.47&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>zheng-boot-cms-admin 的pom.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  &lt;-- zheng-boot-cms-admin pom.xml --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;artifactId&gt;zheng-boot-cms&lt;/artifactId&gt;</span><br><span class="line">		&lt;groupId&gt;cn.choleece.zhengboot&lt;/groupId&gt;</span><br><span class="line">		&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">		&lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;cn.choleece.zhengboot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;zheng-boot-cms-admin&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;zheng-boot-cms-admin&lt;/name&gt;</span><br><span class="line">	&lt;description&gt;zheng-boot-cms-admin&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>下面我们来看一下，分析一下各module的jar都是来自哪里，弄清了来源，基本也就理解了。</p>
<p>先看最底层的，zheng-boot-cms-admin</p>
<p>我们可以看到，在zheng-boot-cms-admin这个module里，有druid 和 fastjson，我们首先看druid，在本pom.xml里，druid没有版本号，则是引用的父pom，admin的父pom里，我们会看到dependencyManagement里有定义druid，所以admin里直接引用的就是cms pom.xml里的版本号，再看fastjson，同样的没有版本号，往上追溯到cms的pom，发现并没有fastjson的定义，接着我们看admin的父pom zheng-boot的dependencyManagement里有定义fastjson，同样是可以引用到的，也就是它会一直往上追溯，直到找到为止。但是需要注意到是，在cms的dependencyManagement里不能引用zheng-boot dependencyManagement的包，否则在子module引用的时候会发现找不到版本号。</p>
<p>我们再看zheng-boot-common里的snowflake，我们在admin项目里是可以直接用的，证明snowflag的jar包已经加载到了amdin的classpath下，我们来看下这是什么样的一个过程。当我们在admin项目里用snowflake的时候，admin会去找自己pom下的jar包，发现没有pom里没有声明，然后继续寻找admin的父pom cms，发现cms 的pom 里也没有明确声明snowflake，但是引用里common，然后common里声明了snowflake，所以admin可以直接使用。</p>
<p>看到上边，我想大家已经清楚了各项目模块下的jar包的来源，也会发现dependency 和 dependencyManagement的区别，它两一个明显的区别就是，如果在父pom的dependency引入的jar包，那么会直接“继承”到子pom里，在子pom里不用显示的引用就可以使用；如果是在父pom的dependencyManagement引入的jar包，则需要在子pom里需要显示的引用，只不过不需要写version。另外，dependencyManagement不支持“继承”，即在zheng-boot 的dependencyManagement里定义的jar包，不能在zheng-boot-cms的dependencyManagement里使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/06/24/thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/24/thread/" itemprop="url">多线程知识面试汇总</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-24T22:14:51+08:00">
                2018-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1. 什么是线程？"></a>1. 什么是线程？</h3><p>线程是操作系统能够进行运算调度的最小单位，它包含在进程中，是进程中的实际运作单位，可以使用多线程对运算进行提速。</p>
<h3 id="2-什么是线程安全和线程不安全？"><a href="#2-什么是线程安全和线程不安全？" class="headerlink" title="2. 什么是线程安全和线程不安全？"></a>2. 什么是线程安全和线程不安全？</h3><p>通俗的说：加锁就是线程安全的，不加锁就是线程不安全的。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全：就是多线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，知道该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p>
<p>一个线程安全的计数器类的同一个实例对象在被对多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全。<br>Vector是用同步方法来实现线程安全的，而和它相似的ArrayList不是线程安全的。</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p>
<h3 id="3-什么是自旋锁？"><a href="#3-什么是自旋锁？" class="headerlink" title="3. 什么是自旋锁？"></a>3. 什么是自旋锁？</h3><p>自旋锁是SMP架构中的一种low-level的同步机制。</p>
<p>当线程A想要获取一把自旋锁而该所又被其他线程持有时，线程A会在一个循环中自旋以检测锁是不是已经可以可用了。</p>
<h4 id="自旋锁需要注意："><a href="#自旋锁需要注意：" class="headerlink" title="自旋锁需要注意："></a>自旋锁需要注意：</h4><ul>
<li>由于自旋不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在那里自旋，这就会浪费CPU时间。</li>
<li>持有自旋锁的线程在sleep之前应该释放自旋锁以便其他线程可以获得自旋锁锁。</li>
</ul>
<p>自旋锁的实现：<br>目前的JVM实现自旋锁会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyWaitNotify &#123;</span><br><span class="line">    MonitorObject myMonitorObject = new MonitorObject();</span><br><span class="line">    boolean wasSignalled = false;</span><br><span class="line"></span><br><span class="line">    public void doWait() &#123;</span><br><span class="line">        synchronized(myMonitorObject) &#123;</span><br><span class="line">            while(!wasSignalled) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    myMoniorObject.wait();</span><br><span class="line">                &#125; catch(InterruptedException e) &#123;...&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // clear singal and continue running..</span><br><span class="line">             wasSinnalled = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doNotify() &#123;</span><br><span class="line">        synchronized(myMonitorObject) &#123;</span><br><span class="line">            wasSignalled = true;</span><br><span class="line">            myMonitorObject.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-什么是Java内存模型？"><a href="#4-什么是Java内存模型？" class="headerlink" title="4. 什么是Java内存模型？"></a>4. 什么是Java内存模型？</h3><p>Java内存模型描述了在多线程中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了”程序中的变量”和”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来做正确实现以上事情。</p>
<p>Java包含了几个语音级别的关键字，包括：volatile, final以及synchronized，目的是为了帮助程序员向编译器描述一个程序的并发需求。Java内存模型定义了volatile和synchronized行为，更重要的是保证了同步的Java程序在所有的处理器架构下面都能正确的运行。</p>
<p>“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致对。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后边会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到这个操作结果，这反映了换成的影响。</p>
<p>此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其能在最佳顺序的情况下执行操作。在内存模型的限定之内，我们能够获取更高的性能。<br>看下面代码展示的一个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class Recording &#123;</span><br><span class="line">    int x = 0, y = 0;</span><br><span class="line"></span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        int r1 = y;</span><br><span class="line">        int r2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看在两个并发线程中执行这段代码，读取Y变量会得到2个这个🈯️值。因为这个写入比写到X变量更晚一些，程序员可能认为读取X变量将肯定得到1，但是，写入操作可能被重排序过，如果重排序发生了，那么就能发生对Y变量的写入操作，读取两个变量的操作紧随其后，而且写入到X这个操作能发生。程序的结果可能是r1变量的值是2，但是r2变量的值为0</p>
<p>但是面试官，有时候不这么认为，认为就是JVM内存结构<br>JVM内存结构主要有三块：对内存、方法区和栈。</p>
<p>堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间，From Survivor空间、To Survivor空间，默认情况下年轻代按照8:1:1的比例来分配；方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法去还有一个别名Non-Heap(非堆)；栈又分为Java虚拟机栈和本地方法栈主要用于方法的执行。</p>
<h4 id="Java的JVM的内存可分为3个区：堆（heap）、栈-stack-和方法区（method）"><a href="#Java的JVM的内存可分为3个区：堆（heap）、栈-stack-和方法区（method）" class="headerlink" title="Java的JVM的内存可分为3个区：堆（heap）、栈(stack)和方法区（method）"></a>Java的JVM的内存可分为3个区：堆（heap）、栈(stack)和方法区（method）</h4><p>Java堆（Java Heap）</p>
<ul>
<li>可通过参数 -Xms和Xmx设置</li>
</ul>
<ol>
<li>Java堆是被所有线程共享，是Java虚拟机所管理的内存中最大的一块Java堆在虚拟机启动时创建。</li>
<li>Java堆唯一堆目的是存放对象实例，几乎所有的对象实例和数组都在这里。</li>
<li>Java堆为了便于更好堆回收和分配内存，可以细分为：新生代和老年代；在细致一点有Eden空间、From Survivor空间、To Survivor区。<br> a. 新生代：包括Eden区、From Survivor区、To Survivor区、系统默认大小Eden : Survivor = 8 : 1;<br> b. 老年代：在年轻代经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中，因此，可以认为老年代中存放的都是一些生命周期较长的对象。</li>
<li>Survivor空间等Java堆可以处在物理上不连续的内存共建中，只要逻辑上是连续的即可。</li>
</ol>
<h5 id="据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。"><a href="#据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。" class="headerlink" title="据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。"></a>据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。</h5><p>本地方法栈</p>
<ul>
<li>可通过参数 栈容量可由-Xss设置</li>
</ul>
<ol>
<li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。</li>
<li>本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。</li>
</ol>
<p>方法区（Method Area）<br>可通过参数-XX:MaxPermSize设置</p>
<ol>
<li>线程共享内粗区域，用于存储已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也称为持久代（Permanent Generation）</li>
<li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫Non-Heap（非堆），目的应该是与Java堆区分开来</li>
<li>如何实现方法区，属于虚拟机的实现细节，不受虚拟机约束规范。</li>
<li>方法去主要方法Java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收，但并不是没有垃圾回收。</li>
<li>方法区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</li>
<li>运行时常量，也是方法区的一部分，虚拟机加载class后把常量池中的数据放入运行时常量池。</li>
</ol>
<p>运行时常量池</p>
<p>JDK1.6之前字符串常量池位于方法区之中。JDK1.7字符串常量池已经被挪到堆之中。<br>可通过参数-XX:PermSize和–XX:MaxPermSize设置</p>
<ul>
<li>常量池（Constant Pool ）：常量池数据编译期被确定，是Class文件中的一部分。存储了类、方法、接口中的常量，当然也包括字符串常量。</li>
<li>字符串池/字符串常量池（String Pool）/（String Constant Pool）：是常量池中一部分，存储编译期类中产生的字符串类型数据。</li>
<li>运行时常量池（Runtime Constant Pool）:方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入到运行时常量池。常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型。</li>
</ul>
<ol>
<li>常量池中主要存放两大类常量：字面量（Literal）和符号饮用（Symbolic Reference）。</li>
<li>字面量：文本字符串、声明为final的常量值等。</li>
<li>符号引用：类和接口的完全限定名（Full Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。</li>
</ol>
<p>直接内存</p>
<p>可通过-XX:MaxDirectMemory指定，如果不指定，则默认与Java堆的最大值（-Xmx）一样。</p>
<ul>
<li>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。</li>
</ul>
<p>总结的简单一点<br>Java堆（Java Heap）<br>可通过参数-Xms 和 -Xmx设置</p>
<ol>
<li>Java堆是被所有线程共享，是Java虚拟机所管理的内存中最大的一块，Java堆在虚拟机启动后创建</li>
<li>Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都放在这里</li>
<li><p>Java堆为了更好的回收和分配内存，可以细分为新生代和老年代；再细致一点分为Eden空间，From Survivor空间，To Survivor空间。</p>
<ul>
<li>新生代：包括Eden区、From Survivor区、To Survivor区，系统默认大小为Eden:Survivor=8：1。</li>
<li>老年代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</li>
</ul>
</li>
</ol>
<p>Java虚拟机栈（Stack）<br>可通过参数栈帧是方法运行期的基础数据结构，栈容量可由-Xss设置</p>
<ol>
<li>Java虚拟机栈是线程私有的，它的生命周期与线程相同。</li>
<li>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</li>
<li>虚拟机栈是执行Java方法的内存模型（也就是字节码）服务：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>
</ol>
<p>方法区（Method Area）<br>可通过-XX:MaxPermSize设置</p>
<ol>
<li>线程共享内存区域，用于已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也被称为持久代（Permanent Generation）</li>
<li>方法区主要存放Java类定义信息，与垃圾回收关系不大，方法区可以现在不实现垃圾回收，但不是没有垃圾回收。</li>
<li>方法区域的内存回收目标只要是针对常量池和堆类型的卸载。</li>
<li><p>运行时常量池，也是方法区的一部分，虚拟机加载Class后把常量池中国呢的数据放入运行时常量池。</p>
</li>
<li><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><p>CAS（compare and swap）的缩写，中文翻译成比较与交换。</p>
</li>
</ol>
<p>CAS不通过JVM，直接利用Java本地方法JNI（Java Native Interface为Java本地调用），直接调用CPU的cmpxchg指令。</p>
<p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法，实现院子操作。其他远离操作都是利用类似的特性完成的。</p>
<p>整个java.util.concurrent都是建立在CAS之上的，因此对于synchronized的阻塞算法，J.U.C在性能上有来了很大的提升。</p>
<p>CAS是项乐观锁技术，当多个线程都尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<h4 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h4><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B，当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<h4 id="CAS优点"><a href="#CAS优点" class="headerlink" title="CAS优点"></a>CAS优点</h4><p>确保对内存的读-改-写操作都是原子操作执行</p>
<h4 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h4><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>使用CAS在线程冲突严重时，会大幅降低程序性能；CAS只适合于线程冲突较少的情况使用。</li>
<li>synchronized在JDK1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ol>
<h3 id="6-什么是乐观锁和悲观锁？"><a href="#6-什么是乐观锁和悲观锁？" class="headerlink" title="6. 什么是乐观锁和悲观锁？"></a>6. 什么是乐观锁和悲观锁？</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以说synchronize是悲观锁。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁（Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回用户错误的信息，让用户决定如何去做。</p>
<h3 id="6-什么是原子操作？在Java-Concurrency-API中有哪些原子类（atomic-classes）？"><a href="#6-什么是原子操作？在Java-Concurrency-API中有哪些原子类（atomic-classes）？" class="headerlink" title="6. 什么是原子操作？在Java Concurrency API中有哪些原子类（atomic classes）？"></a>6. 什么是原子操作？在Java Concurrency API中有哪些原子类（atomic classes）？</h3><p>原子操作是指一个不受其他操作影响的操作任何单元。原子操作是在多线程环境下避免数据不一致必须的手段</p>
<p>i++并不是一个原子操作，所以当一个线程读取它的值并+1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术做到这一点。</p>
<p>在JDK1.5之后，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p>
<h3 id="7-什么是Executors框架？"><a href="#7-什么是Executors框架？" class="headerlink" title="7. 什么是Executors框架？"></a>7. 什么是Executors框架？</h3><p>Executor框架同java.util.concurrent.Executor接口在Java5中被引入。</p>
<p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务框架。</p>
<p>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。</p>
<p>利用Executor框架可以非常方便的创建一个线程池，</p>
<p>Java通过Executors提供四种线程池，分别为：</p>
<p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需求，可灵活回收空闲线程，若无可回收，则创建新线程。</p>
<p>newFixedThreadPool创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>newSingleThreadExecutor创建一个但线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行。</p>
<h3 id="8-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#8-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="8.什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"></a>8.什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>JDK7提供了7个阻塞队列。（也属于并发容器）</p>
<ol>
<li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDueue：一个由链表结构组成的双向阻塞队列。</li>
</ol>
<h4 id="什么是阻塞队列？"><a href="#什么是阻塞队列？" class="headerlink" title="什么是阻塞队列？"></a>什么是阻塞队列？</h4><p>阻塞队列是一个在队列基础上又支持了两个附加操作的队列。</p>
<p>2个附加操作：</p>
<p>支持阻塞的插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>支持阻塞的移除方法：队列空时，获取元素的线程会等待队列变为非空。</p>
<p>阻塞队列的应用场景</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。简而言之，阻塞队列是生产者用来存放元素、消费者用来获取元素的容器。</p>
<p>Java里的阻塞队列，如下</p>
<ol>
<li>ArrayBlockingQueue 数组结构组成的有界阻塞队列。</li>
</ol>
<p>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程队列访问的顺序是不能保证线程公平（即先阻塞，先插入的）。</p>
<ol>
<li>LinkedBlockingQueue一个由链表组成的有界阻塞队列</li>
</ol>
<p>此队列按照先进消除的原则对元素进行排序</p>
<ol>
<li><p>PriorityBlockingQueue支持优先级的无界阻塞队列</p>
</li>
<li><p>DelayQueue支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素</p>
</li>
<li><p>SynchronousQueue不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列</p>
</li>
<li><p>LinkedTransferQueue由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法。</p>
</li>
</ol>
<p>transfer方法</p>
<p>如果当前有消费者正在等待接受元素（take或者待时间限制的poll方），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费力才返回。</p>
<p>tryTransfer方法</p>
<p>用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。</p>
<ol>
<li>LinkedBlockingDeque链表结构的双向阻塞队列，优势在于多线程入队时，减少一半的竞争。</li>
</ol>
<p>如何使用阻塞队列来实现生产者-消费者模型？</p>
<p>通知模式实现：所谓通知模式，及时当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费里一个队列中的元素后，会通知生产者当前队列可用。</p>
<p>使用BlockingQueue解决生产者消费者问题</p>
<p>为什么BlockingQueue适合解决生产者消费者问题</p>
<p>任何有效的生产者-消费者问题解决方案通过都是通过控制生产者put()方法（生产资源）和消费者take()方法（消费资源）的调用来实现的，一旦你实现了对方法的阻塞控制，那么你就将解决该问题。</p>
<p>Java通过BlockingQueue提供了开箱即用的支持来控制这些方法的调用（一个线程创建资源，另一个消费资源）。Java.util.concurrent包下的BlockingQueue接口是一个线程安全的可用于存取对象的队列。</p>
<p>BlockingQueue是一种数据结构，支持一个线程往里存资源，另一个线程从里取资源。这正式解决生产者消费者问题所需要的，那么让我们开始解决该问题吧。</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>以下代码用于生产者线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 生产者</span><br><span class="line"> *</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class Producer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    protected BlockingQueue&lt;Object&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    public Producer(BlockingQueue&lt;Object&gt; blockingQueue) &#123;</span><br><span class="line">        this.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Object justProduced = getResource();</span><br><span class="line">                blockingQueue.put(justProduced);</span><br><span class="line">                System.out.println(&quot;生产者资源队列大小==&quot; + blockingQueue.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;生产者 写 中断&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object getResource() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;生产者 读 中断&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<p>以下代码用于消费者线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消费者</span><br><span class="line"> *</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    protected BlockingQueue&lt;Object&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    public Consumer(BlockingQueue&lt;Object&gt; blockingQueue) &#123;</span><br><span class="line">        this.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Object obj = blockingQueue.take();</span><br><span class="line">                System.out.println(&quot;消费者队列大小：&quot; + blockingQueue.size());</span><br><span class="line">                take(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">            System.out.println(&quot;消费者 中断&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void take(Object obj) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;消费者 读 中断&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;消费对象：&quot; + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试该解决方案是否运行正常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 启动线程</span><br><span class="line"> *</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class PCExample &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int proNum = 4, cusNum = 3;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;Object&gt; blockingQueue = new LinkedBlockingQueue&lt;Object&gt;(5);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; proNum; i++) &#123;</span><br><span class="line">            new Thread(new Producer(blockingQueue)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; cusNum ; i++) &#123;</span><br><span class="line">            new Thread(new Consumer(blockingQueue)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;在我之后就结束了&quot;);</span><br><span class="line"></span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">主线程</span><br><span class="line">生产者资源队列大小==3</span><br><span class="line">消费者队列大小：3</span><br><span class="line">消费者队列大小：2</span><br><span class="line">消费者队列大小：1</span><br><span class="line">生产者资源队列大小==4</span><br><span class="line">生产者资源队列大小==2</span><br><span class="line">生产者资源队列大小==3</span><br><span class="line">生产者资源队列大小==2</span><br><span class="line">消费对象：java.lang.Object@6ca1879</span><br><span class="line">消费对象：java.lang.Object@24e07882</span><br><span class="line">消费对象：java.lang.Object@1da459ca</span><br><span class="line">消费者队列大小：3</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">生产者资源队列大小==4</span><br><span class="line">生产者资源队列大小==3</span><br><span class="line">消费者队列大小：2</span><br><span class="line">生产者资源队列大小==3</span><br><span class="line">生产者资源队列大小==4</span><br><span class="line">消费对象：java.lang.Object@2a27926e</span><br><span class="line">消费对象：java.lang.Object@80df6d0</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费对象：java.lang.Object@199bcea6</span><br><span class="line">消费者队列大小：3</span><br><span class="line">生产者资源队列大小==4</span><br><span class="line">消费对象：java.lang.Object@c327309</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费对象：java.lang.Object@2e1813f2</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@5c9953f1</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@6b1a9855</span><br><span class="line">消费对象：java.lang.Object@4930fceb</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费对象：java.lang.Object@52da10a1</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：5</span><br><span class="line">消费对象：java.lang.Object@1fef2c64</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@4c99d9dc</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@6d0f6939</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@7833f23f</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@5a3b96c3</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@2aa674c0</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@67067c0b</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@345289f5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@3cb6acbe</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@291f03a4</span><br><span class="line">消费者队列大小：5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@b35671a</span><br><span class="line">消费对象：java.lang.Object@3eebec91</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费者队列大小：5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">在我之后就结束了</span><br></pre></td></tr></table></figure>
<p>从输出结果中，我们可以发现队列大小永远不会超过5，消费者线程消费了生产者生产的资源。</p>
<h3 id="9-什么是Callable和Future？"><a href="#9-什么是Callable和Future？" class="headerlink" title="9. 什么是Callable和Future？"></a>9. 什么是Callable和Future？</h3><p>Callable和Future是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到他们。Callable用于产生结果，Future用于获取结果。</p>
<p>Callable接口使用泛型去定义它的返回类型，Executors类提供类一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决类这个问题。</p>
<p>在线程池提交Callable任务后返回类一个Future对象，使用它可以直到Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。</p>
<p>代码示例</p>
<p>Callable是一个结构，它只包含一个cal()方法。Callable是一个返回结果并且可能抛出异常的任务。</p>
<p>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似与Runnable的run()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * callable &amp; future</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class CallableFutureTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        System.out.println(&quot;start main thread&quot;);</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">        // 新建一个callable任务，并将其提交到ExecutorService，将返回一个描述任务情况的Future</span><br><span class="line">        Callable&lt;String&gt; callable = new Callable&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                System.out.println(&quot;start new thread&quot;);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                System.out.println(&quot;end new thread&quot;);</span><br><span class="line">                return &quot;我是返回的内容&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = service.submit(callable);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        String retn = future.get();</span><br><span class="line">        // 关闭线程池</span><br><span class="line">        service.shutdown();</span><br><span class="line">        System.out.println(retn + &quot;------end main thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start main thread</span><br><span class="line">start new thread</span><br><span class="line">end new thread</span><br><span class="line">我是返回的内容------end main thread</span><br></pre></td></tr></table></figure>
<h3 id="10-什么是FutureTask"><a href="#10-什么是FutureTask" class="headerlink" title="10. 什么是FutureTask?"></a>10. 什么是FutureTask?</h3><p>FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。另外，FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。</p>
<ol>
<li>执行多任务计算</li>
</ol>
<p>FutureTask执行多任务计算的使用场景</p>
<p>利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，当主线程需要子线程的计算结果时，再异步获取子线程的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 执行多任务计算</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class FutureTaskForMultiCompute &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FutureTaskForMultiCompute inst = new FutureTaskForMultiCompute();</span><br><span class="line"></span><br><span class="line">        // 创建任务集合</span><br><span class="line">        List&lt;FutureTask&lt;Integer&gt;&gt; taskList = new ArrayList&lt;FutureTask&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 创建线程池</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(5);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            // 传入callable对象创建FutureTask对象</span><br><span class="line">            FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(inst.new ComputeClass(i, &quot;&quot; + i));</span><br><span class="line">            taskList.add(ft);</span><br><span class="line">            // 提交给线程池执行任务，也可用exec的invokeAll(taskList)方法一次性提交素有任务</span><br><span class="line">            exec.submit(ft);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;所有计算任务提交完毕，主线程接着干其他的事情&quot;);</span><br><span class="line"></span><br><span class="line">        // 开始统计各计算线程的结果</span><br><span class="line">        Integer totalResult = 0;</span><br><span class="line">        for (FutureTask&lt;Integer&gt; ft : taskList) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // FutureTask的get()方法会自动阻塞，直到获取计算结果为止</span><br><span class="line">                totalResult += ft.get();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        System.out.println(&quot;多任务计算后的总结果是：&quot; + totalResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class ComputeClass implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private Integer result = 0;</span><br><span class="line"></span><br><span class="line">        private String taskName = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        public ComputeClass(Integer result, String taskName) &#123;</span><br><span class="line">            this.result = result;</span><br><span class="line">            this.taskName = taskName;</span><br><span class="line">            System.out.println(&quot;生成子线程任务：&quot; + taskName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getTaskName() &#123;</span><br><span class="line">            return taskName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            // 休眠5秒钟，观察主线程行为，预期的结果是主线程会继续执行，到要取到FutureTask的结果时等待直至完成</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            System.out.println(&quot;子线程计算任务： &quot; + taskName + &quot; 计算完成&quot;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">生成自线程任务：0</span><br><span class="line">生成自线程任务：1</span><br><span class="line">生成自线程任务：2</span><br><span class="line">生成自线程任务：3</span><br><span class="line">生成自线程任务：4</span><br><span class="line">生成自线程任务：5</span><br><span class="line">生成自线程任务：6</span><br><span class="line">生成自线程任务：7</span><br><span class="line">生成自线程任务：8</span><br><span class="line">生成自线程任务：9</span><br><span class="line">所有计算任务提交完毕，主线程接着干其他的事情</span><br><span class="line">子线程计算任务： 0 计算完成</span><br><span class="line">子线程计算任务： 2 计算完成</span><br><span class="line">子线程计算任务： 1 计算完成</span><br><span class="line">子线程计算任务： 3 计算完成</span><br><span class="line">子线程计算任务： 4 计算完成</span><br><span class="line">子线程计算任务： 6 计算完成</span><br><span class="line">子线程计算任务： 8 计算完成</span><br><span class="line">子线程计算任务： 7 计算完成</span><br><span class="line">子线程计算任务： 5 计算完成</span><br><span class="line">子线程计算任务： 9 计算完成</span><br><span class="line">多任务计算后的总结果是：49545</span><br></pre></td></tr></table></figure></p>
<ol>
<li>高并发环境下</li>
</ol>
<p>FutureTask在高并发环境下确保任务只执行一次</p>
<p>在很多高并发环境下，往往我们只需要某些任务只执行一次。这种使用场景FutureTask的特性恰好能胜任。举一个例子，假设有一个带key的连接池，当key存在时，即直接返回key对应的对象；当key不存在时，则创建链接。对于这样的应用场景，通常采用的方法为使用一个Map对象来存储key和连接池对应的对应刮洗，典型的代码如下面所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Connection&gt; connectionPool = new HashMap&lt;String, Connection&gt;();</span><br><span class="line">private ReentrantLock lock = new ReentrantLock();</span><br><span class="line">public Conncetion getConnection(String key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        if (connectionPool.containsKey(key)) &#123;</span><br><span class="line">            return connectionPool.get(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 创建connection</span><br><span class="line">            Connection coon = createConnection();</span><br><span class="line">            connectionPool.put(key, coon);</span><br><span class="line">            return coon;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        loco.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建connection</span><br><span class="line"></span><br><span class="line">private Connection createConnection() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们通过枷锁确保高并发环境下的线程安全，也确保了connection 只创建一次，然而确牺牲了性能。改用ConcurrentHash的情况下，几乎可以避免枷锁的操作，性能大大提高，但是在高并发的情况下有可能出现Connection被创建多次的现象。这时最需要解决的问题就是当key不存在时，创建Connection的动作能放在connectionPool之后执行，这正式FutureTask发挥作用的时机，基于ConcurrentHashMap和FutureTask的改造代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private ConcurrentHashMap&lt;String, FutureTask&lt;Connection&gt;&gt; connectionPool = new ConcurrentHashMap&lt;String, FutureTask&lt;Connection&gt;&gt;();</span><br><span class="line"></span><br><span class="line">public Connection getConnection(String key) throws Exception &#123;</span><br><span class="line">    FutureTask&lt;Connection&gt; connectionTask = connectionPool.get(key);</span><br><span class="line">    if (connectionTask != null) &#123;</span><br><span class="line">        return connectionTask.get();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Callable&lt;Connection&gt; callable = new Callable&lt;Connection&gt;() &#123;</span><br><span class="line">            @override</span><br><span class="line">            public Connection call() throws Exception &#123;</span><br><span class="line">                return createConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Connection&gt; newTask = new FutureTask&lt;Connection&gt;(callable);</span><br><span class="line">        connectionTask = connectionPool.put(key, newTask);</span><br><span class="line">        if (connectionTask != null) &#123;</span><br><span class="line">            connectionTask = newTask;</span><br><span class="line">            connectionTask.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return connectionTask.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建connection</span><br><span class="line">private Connection createConnection() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过这样的改造，可以避免由于并发带来的多次创建链接及锁的出现。</p>
<h3 id="11-什么是同步容器和并发容器的实现？"><a href="#11-什么是同步容器和并发容器的实现？" class="headerlink" title="11. 什么是同步容器和并发容器的实现？"></a>11. 什么是同步容器和并发容器的实现？</h3><p>一、同步容器</p>
<p>主要代表有Vector和HashTable，以及Collections.sychronizedXxx等。锁的粒度为当前对象整体。迭代器是及时失败的，即在迭代过程中发现被修改，就会抛出ConcurrentModificationException。</p>
<p>二、并发容器</p>
<p>主要有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。锁的粒度是分散的、细粒度的，即读和写使用不同的锁。迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</p>
<p>JDK7 ConcurrentHashMap</p>
<p>采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问；</p>
<p>JDK8 ConcurrentHashMap</p>
<p>采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问；</p>
<p>三、阻塞队列</p>
<p>主要有LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue(Comparable、Comparator)、SynchronousQueue。提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。适用于生产者、消费者（线程池和工作队列-Executor）,同时也是同步容器。</p>
<p>四、双端队列</p>
<p>主要代表有ArrayDeque和LinkedBlockingDeque。意义：正如阻塞对垒适用于生产者消费者模式，双端队列同样适用于另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。如果一个消费者完成了自己的双端队列的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它就从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。适用于：网页爬虫等任务中。</p>
<p>五、比较及适用场景</p>
<p>如果不需要阻塞队列，优先选择ConcurrentLinkedQueue；如果需要阻塞队列，队列的大小固定优先选择ArrayBlockingQueue，队列的大小不固定优先选择LinkedBlockingQueue；如果需要队列进行排序，选择PriorityBlockingQueue；如果需要一个快速交换的队列，选择SynchronousQueue; 如果需要对队列中的元素进行延时操作，则选择DelayQueue。</p>
<h3 id="12-什么是多线程？优缺点？"><a href="#12-什么是多线程？优缺点？" class="headerlink" title="12. 什么是多线程？优缺点？"></a>12. 什么是多线程？优缺点？</h3><p>什么是多线程？</p>
<p>多线程：是指从软件或者硬件上实现多个线程的并发技术。</p>
<p>多线程的好处：</p>
<ol>
<li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的下载</li>
<li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好</li>
</ol>
<p>多线程的缺点：</p>
<ol>
<li>大量的线程降低代码的可读性</li>
<li>更多的线程需要更多的内存空间</li>
<li>当多个线程对同一个资源出现争夺时候要注意线程安全的问题。</li>
</ol>
<h3 id="13-什么是多线程的上下文切换？"><a href="#13-什么是多线程的上下文切换？" class="headerlink" title="13. 什么是多线程的上下文切换？"></a>13. 什么是多线程的上下文切换？</h3><p>即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间。因为时间片非常短，所以CPU通过不停的切换线程执行，让我们感觉多个线程同时执行，时间片一般是几十毫秒</p>
<p>上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体为止以便之后继续运行。</p>
<p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态。</p>
<ul>
<li>从任务保存到再加载的过程就是一次上下文切换</li>
</ul>
<h3 id="14-ThreadLocal的设计理念和作用？"><a href="#14-ThreadLocal的设计理念和作用？" class="headerlink" title="14. ThreadLocal的设计理念和作用？"></a>14. ThreadLocal的设计理念和作用？</h3><p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量</p>
<p>ThreadLocal</p>
<p>如何创建ThreadLocal变量：</p>
<pre><code>private ThreadLocal myTHreadLocal = new ThreadLocal();
</code></pre><p>通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，它们仍然无法访问到对方的值。</p>
<p>如何访问ThreadLocal变量</p>
<p>一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值：</p>
<pre><code>myTHreadLocal.set(&quot; A thread local value&quot;);
</code></pre><p>可以通过下面方法读取保存在ThreadLocal变量中的值：</p>
<pre><code>String threadLocalValue = (String) myThreadLocal.get();
</code></pre><p>get()方法返回一个Object对象，set()对象需要传入一个Object类型的参数。</p>
<p>为ThreadLocal指定泛型类型</p>
<pre><code>public static ThreadLocal&lt;String&gt; myThreadLocal = new ThreadLocal&lt;String&gt;();
</code></pre><p> 我们可以创建一个执行泛型的ThreadLocal对象，这样我们就不需要每次对使用get()方法返回的值作强制类型转换了。</p>
<p> ThreadLocal的介绍</p>
<p> ThreadLocal是一个线程的内部存储类，可以在每个线程的内部存储数据，当某个数据的作用域应该对应线程的时候就应该使用它；</p>
<p> 而是当某个很复杂的逻辑下的对象传递，需要在线程这个作用域内贯穿其中，用ThreadLocal可以避免这个创建多个静态类。</p>
<p> 当你创建一个ThreadLocal对象后，注意，是一个对象，你在不同线程中去访问它的值是可以不一样滴，并且是和线程相关联的。</p>
<p> 它的实现原理其实比较简单，每个线程中都会维护一个ThreadLocalMap，当在某个线程中访问时，会取出这个线程自己的Map并且用当前ThreadLocal对象作索引来取出相对应的value值，从而达到不同线程不同值的效果。</p>
<p> 实现原理</p>
<ol>
<li><p>每个Thread对象内部都维护来一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个ThreadLocal。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value,否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        THreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            return (T) e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们调用set()方法的时候，很常规，就是将值设置进ThreadLocal中。</p>
</li>
<li><p>ThreadLocalMap里面存储的Entry对象本质上是一个WeakReference<threadlocal>。</threadlocal></p>
<p>也就是说，ThreadLocalMap里面存储的对象本质是一个对ThreadLocal对象的弱引用，该ThreadLocal随时可能会被回收。</p>
<p>即导致ThreadLocalMap里面对应的value的key是null。我们需要把这样的Entry给清除掉，不要让他们占坑，避免内存泄漏。</p>
<p>那为什么需要弱引用呢？</p>
<p>因为线程的声明周期是长于ThreadLocal对象的，当此对象不再需要的时候如果线程中还持有它的引用势必也会产生内存泄漏的问题，所以自然应该是用弱引用来进行key的保护。</p>
</li>
</ol>
<h3 id="15-ThreadPool-线程池-用法与优势？"><a href="#15-ThreadPool-线程池-用法与优势？" class="headerlink" title="15. ThreadPool(线程池)用法与优势？"></a>15. ThreadPool(线程池)用法与优势？</h3><p> 为什么要用线程池：</p>
<ol>
<li><p>减少创建和销毁线程的次数，每个工作线程可以被重复利用，可执行多个任务。</p>
</li>
<li><p>可以根据系统的承受能力，调整线程池中工作线程线程数目，防止因为消耗过多的内存，而把服务搞死机</p>
</li>
<li><p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p>new Thread 缺点</p>
</li>
<li><p>每次new Thread新建对象性能差</p>
</li>
<li><p>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或OOM</p>
</li>
<li><p>缺乏更多功能，如定时执行，定期执行，线程中断</p>
<p>ThreadPool优点</p>
<p>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</p>
<p>可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而让服务器死机</p>
</li>
</ol>
<ul>
<li>减少在创建和销毁线程上所画的时间以及系统资源的开销</li>
<li><p>如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存</p>
<p>Java提供的四种线程池的好处在于：</p>
</li>
</ul>
<ol>
<li>重用存在的线程，减少对象创建、销毁的开销，提高性能。</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免阻塞。</li>
<li><p>提供定时执行，定期执行，单线程，并发书控制等功能。</p>
<p>比较重要的几个类：</p>
<p>| 类 | 描述 |<br>| :— | :—-: |<br>| ExecutorService | 真正的线程池接口。 |<br>| ScheduledExecutorService    | 能和Timer/TimerTask类似，解决哪些需要任务重复执行的问题      |<br>| ThreadPoolExecutor   | ExecutorService的默认实现  |<br>| ScheduledThreadPoolExecutor  | 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现|。</p>
<p>要配置一个线程池是比较复杂的，尤其是对线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供类一些静态工厂，生成一些常用的线程池。</p>
<p>Executors提供四种线程池</p>
<p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可回收空闲线程，若无可回收，则创建新线程。</p>
<p>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列总等待。</p>
<p>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>newScheduledThreadPool创建一个单线程化的线程池，它只会用唯一的工作线程来保证执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行。</p>
<p>一般都不用Executors提供的线程创建方式</p>
<p>使用ThreadPoolExecutor创建线程池</p>
<p>ThreadPoolExecutor的构造函数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;= 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        this.workQueue = workQueue;</span><br><span class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ol>
<li><p>corePoolSize核心线程数大小，当线程数 &lt; corePoolSize，会创建线程执行runnable</p>
</li>
<li><p>maximumPoolSize最大线程数，当线程数 &gt;= corePoolSize的时候，会把runnable房屋workQueue中</p>
</li>
<li><p>keepAliveTime保持存活时间，当线程数 &gt; corePoolSize的空闲线程能保持的最大时间。</p>
</li>
<li><p>unit 时间单位</p>
</li>
<li><p>workQueue保存任务的阻塞队列</p>
</li>
<li><p>threadFactory 创建线程的工厂</p>
</li>
<li><p>handler 拒绝策略</p>
</li>
</ol>
<p>任务执行顺序：</p>
<ol>
<li><p>当线程数小于 corePoolSize，创建线程执行任务</p>
</li>
<li><p>当线程数大于等于 corePoolSize 并且workQueue没有满时，放入workQueue中</p>
</li>
<li><p>当线程数大于等于 corePoolSize并且当workQueue满时，新任务新建线程运行，线程总数要小于maximumPoolSize</p>
</li>
<li><p>当线程总数等于maximumPoolSize并且workQueue满了的时候执行handler的rejectedExecutor。也就是拒绝策略</p>
</li>
</ol>
<p>ThreadPoolExecutor默认有四个拒绝策略：</p>
<ol>
<li><p>ThreadPoolExecutor.AbortPolicy() 直接抛出异常，RejectedExecutionException</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy()直接调用run方法并阻塞执行</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy()直接丢弃后来的任务</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务</p>
</li>
</ol>
<p>当然可以自己继承RejectedExecutionHandler来写拒绝策略</p>
<p>参考来源：<a href="https://juejin.im/post/5aae4e8f6fb9a028e52d9e8c" target="_blank" rel="noopener">https://juejin.im/post/5aae4e8f6fb9a028e52d9e8c</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/06/03/reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/reflection/" itemprop="url">Java 反射</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T10:13:57+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java反射浅析"><a href="#Java反射浅析" class="headerlink" title="Java反射浅析"></a>Java反射浅析</h3><pre><code>Java反射机制是在运行状态中，对任意一个类都能知道这个类的属性和方法；
对任意一个对象，都能调用它的任意属性和方法；
</code></pre><h4 id="反射机制获取类的三种方法"><a href="#反射机制获取类的三种方法" class="headerlink" title="反射机制获取类的三种方法"></a>反射机制获取类的三种方法</h4><ol>
<li><p>通过类名 + .class直接获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Student.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象调用getClass()直接获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Student();</span><br><span class="line">obj.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过全类名获取，用得比较多，但可能抛出ClassNotFoundException</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;com.choleece.Student&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="利用newInstance创建对象，调用的类必须要有无参的构造函数"><a href="#利用newInstance创建对象，调用的类必须要有无参的构造函数" class="headerlink" title="利用newInstance创建对象，调用的类必须要有无参的构造函数"></a>利用newInstance创建对象，调用的类必须要有无参的构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;com.choleece.Student&quot;);</span><br><span class="line">// 所以我们在写类的时候，必须写一个无参的构造函数，就是给反射用的</span><br><span class="line">Object obj = clazz.newInstance();</span><br></pre></td></tr></table></figure>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取类全部的构造方法</span><br><span class="line">Constructor&lt;Student&gt;[] constructors = (Constructor&lt;Student&gt;[]) Class.forName(&quot;com.choleece.Student&quot;).getConstructors();</span><br><span class="line"></span><br><span class="line">// 获取类制定的构造方法</span><br><span class="line">Constructor&lt;Student&gt; constructor = (Constructor&lt;Student&gt;) Class.forName(&quot;com.choleece.Student&quot;).getCOnstructor(String.class, Integer.class);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/05/31/java-reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/java-reference/" itemprop="url">java-reference</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T07:32:07+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java-强引用、弱引用、软引用、虚引用的区别"><a href="#Java-强引用、弱引用、软引用、虚引用的区别" class="headerlink" title="Java 强引用、弱引用、软引用、虚引用的区别"></a>Java 强引用、弱引用、软引用、虚引用的区别</h3><h4 id="Java-中有如下四种引用类型"><a href="#Java-中有如下四种引用类型" class="headerlink" title="Java 中有如下四种引用类型"></a>Java 中有如下四种引用类型</h4><ol>
<li>强引用 StrongReference</li>
<li>弱引用 WeekReference</li>
<li>软引用 SoftReference</li>
<li>虚引用 PhantomReference</li>
</ol>
<p>强引用是我们在编程过程中最简单的引用，如String s = “abc”中变量s就是对字符串”abc”的强引用，任何被强引用指向的对象都不能被GC回收，这些对象都是在程序中需要的。弱引用使用java.lang.ref.WeakReference class表示，我们可以使用如下代码创建弱引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Counter counter = new Counter(); // strong reference</span><br><span class="line">WeakReference&lt;Counter&gt; wf = new WeakReference&lt;Counter&gt;(counter); // weak</span><br><span class="line">counter = null; // 现在counter 是可以被GC回收的</span><br></pre></td></tr></table></figure>
<p>在给对象赋值null后，该对象就可以被GC回收。该对象不再有强引用，即使该对象有若引用，也会被GC立即回收，相反，如果该对象有软引用，counter不会被立即回收，除非JVM需要内存，Java中的软引用使用java.lang.ref.SoftReference类来表示，我们可以使用如下代码创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference soft = new SoftReference(counter);</span><br></pre></td></tr></table></figure></p>
<p>鉴于软引用和弱引用这一区别，软引用更适用于缓存机制，弱引用更适用于存储元数据。另一个使用软引用的例子是，WeakHashMap，它有一个特点，map里边的key都被封装成弱引用，也就是说，一旦强引用被删除，WeakHashMap内部的弱引用就无法组织GC对该对象的回收。<br>虚引用是java.lang.ref包中的第三种引用，使用java.lang.ref.PhantomReference类来表示。拥有虚引用的对象可以在任何时候被GC回收，和其他形式类似，创建虚引用的形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference pr = new PhantomReference(counter);</span><br></pre></td></tr></table></figure></p>
<p>一个对象的生命周期如下图所示：<br><img src="/2018/05/31/java-reference/afd3fcba0d61a802c4a8ae970059ee77.gif" title="对象生命周期"></p>
<p>原文出处：<a href="http://www.importnew.com/10866.html" target="_blank" rel="noopener">http://www.importnew.com/10866.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/03/22/java-design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/java-design-pattern/" itemprop="url">设计模式 Java篇</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T22:51:49+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="设计模式-Java篇"><a href="#设计模式-Java篇" class="headerlink" title="设计模式  Java篇"></a>设计模式  Java篇</h3><p>  GoF设计模式有23个，它们各具特色，每一个设计模式都为某一个可重复的设计问题提供了一套解决方案。根据它们的用途，设计模式可分为创建型（Creational），结构型（Structural）和行为型（Behavioral）三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配指责，在GoF设计模式中包含5种创建型设计模式，7种结构型设计模式和11种行为型设计模式。</p>
<h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><p>  对于面向对象软件系统的设计，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题。如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。面向对象设计原则为支持可维护性复用而诞生。</p>
<p>  最常见的7中面向对象设计原则如下表所示：</p>
  <img src="/2018/03/22/java-design-pattern/design_principle.jpg" title="常见设计原则">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/03/19/certbot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/certbot/" itemprop="url">https 安全证书部署 certbot let's encrypt</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T07:24:40+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Let’s-Encrypt-Https-安全证书-certbot"><a href="#Let’s-Encrypt-Https-安全证书-certbot" class="headerlink" title="Let’s Encrypt Https 安全证书 certbot"></a>Let’s Encrypt Https 安全证书 certbot</h3><p>为了使你的网站支持https，你必须从Certificate Authority（CA）获得一个证书， Let’s Encrypt 就是一个CA。Let’s Encrypt部署起来很简单，使用电子子前哨基金会的Certbot就可以完成，下面就介绍利用Certbot完成https的部署。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1.打开Let’s Encrypt 官网</p>
<p>  <a href="https://letsencrypt.org/getting-started/" target="_blank" rel="noopener">https://letsencrypt.org/getting-started/</a></p>
<p>2.选择其中的With Shell Access，点击Certbot来到Certbot官网，前两步也可直接点击Certbot官网</p>
<p>  <a href="https://certbot.eff.org/lets-encrypt/" target="_blank" rel="noopener">https://certbot.eff.org/lets-encrypt/</a></p>
<p>3.根据自己的的服务器需求安装，我选的是Nginx + Centos7</p>
<img src="/2018/03/19/certbot/certbot.jpg" title="选择服务器环境">
<p>4.为了立马就能看见效果，先保证nginx 80端口已经开启。接下来按照官网的步骤走</p>
<p>首先允许EPEL仓库</p>
<pre><code>yum -y install yum-utils
yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional
</code></pre><p>安装certbot-nginx</p>
<pre><code>yum install certbot-nginx
</code></pre><p>开始运行</p>
<pre><code>certbot --nginx
</code></pre><p>以上步骤是certbot官方网站上的操作步骤，进行这一步时，回出现错误，错误如下：</p>
<img src="/2018/03/19/certbot/certbot_error.jpg" title="运行报错">
<p>解决方案<br>  以上报错是python包没找到，下边介绍另外一种方法，利用pip进行安装</p>
<p>  首先升级pip</p>
<pre><code>pip install --upgrade pip
</code></pre><p>  卸载yum安装的certbot和pyOpenSSL</p>
<pre><code>yum remove certbot-nginx pyOpenSSL
</code></pre><p>  pip安装certbot</p>
<pre><code>pip install certbot-nginx
</code></pre><p>  如果碰到了Python.h或者pyconfig.h找不到的错误，于是安装Python的devel包（不一定会出现）：</p>
<pre><code>yum install -y python-devel
</code></pre><p>  再次运行pip install certbot-nginx,如果提示找不到opensslv.h头文件，于是安装OpenSSL的devel包（不一定出现）：</p>
<pre><code>yum install -y openssl-devel
</code></pre><p>  如果pip install certbot-nginx 一次成功，则不需要运行上边两句命令。</p>
<p>  有时候根据系统的不同会出现不同的情况，近期在配置系统的上述方法不太好用，具体原因是pyOpenSSL版本太高，当时操作的时候是18,用yum默认安装的是0.13，但是certbot运行的版本要求&gt;=0.14，然后我试着重新去下载了0.15,发现有另外一个问题，然后重新下了一遍0.17，奇迹般的好用了，下面贴出下载链接：<br>  <a href="http://rpm.pbone.net/index.php3/stat/4/idpl/44092374/dir/centos_7/com/python2-pyOpenSSL-17.3.0-3.el7.noarch.rpm.html" target="_blank" rel="noopener">http://rpm.pbone.net/index.php3/stat/4/idpl/44092374/dir/centos_7/com/python2-pyOpenSSL-17.3.0-3.el7.noarch.rpm.html</a><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先进行下载：</span><br><span class="line">    wget ftp://ftp.ntua.gr/pub/linux/centos/7.5.1804/cloud/x86_64/openstack-queens/python2-pyOpenSSL-17.3.0-3.el7.noarch.rpm;</span><br><span class="line">然后安装:</span><br><span class="line">    rpm -Uvh pyOpenSSL.**.rpm</span><br></pre></td></tr></table></figure></p>
<p>自动续期</p>
<p>  let’s encrypt 证书默认的有效期是90天的时间，所以我们需要自动续期</p>
<p>  先来添加一个service</p>
<pre><code>$ sudo vim /etc/systemd/system/letsencrypt.service

[Unit]
Description=Let&apos;s Encrypt renewal

[Service]
Type=oneshot
ExecStart=/usr/bin/certbot renew --quiet --agree-tos
ExecStartPost=/bin/systemctl reload nginx.service
</code></pre><p>  然后添加一个systemd timer来定时触发这个任务</p>
<pre><code>$ sudo vim /etc/systemd/system/letsencrypt.timer
[Unit]
Description=Daily renewal of Let&apos;s Encrypt&apos;s certificates

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
</code></pre><p>  启动服务，开启timer</p>
<pre><code>$ sudo systemctl enable letsencrypt.timer
$ sudo systemctl start letsencrypt.timer
</code></pre><p>  以上总体按照官网每次操作都有不同的问题，希望能出个稳定的版本，反正按照官网的步骤，一定是会出错（至少我实践这么多次是这样）</p>
<p>参考链接：</p>
<p>  <a href="https://letsencrypt.org/getting-started/" target="_blank" rel="noopener">https://letsencrypt.org/getting-started/</a></p>
<p>  <a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx" target="_blank" rel="noopener">https://certbot.eff.org/lets-encrypt/centosrhel7-nginx</a></p>
<p>  <a href="https://tlanyan.me/certbot-importerror-pyopenssl-module-missing-required-functionality/" target="_blank" rel="noopener">https://tlanyan.me/certbot-importerror-pyopenssl-module-missing-required-functionality/</a></p>
<p>  <a href="https://blog.nswebfrog.com/2017/12/14/letsencrypt-renew/" target="_blank" rel="noopener">https://blog.nswebfrog.com/2017/12/14/letsencrypt-renew/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/01/16/tab-view-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/tab-view-md/" itemprop="url">小程序顶部TabView</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T23:03:11+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面我们将利用小程序的scroll-view &amp; swipper制作tab-view</p>
<h3 id="建立wxml"><a href="#建立wxml" class="headerlink" title="建立wxml"></a>建立wxml</h3><p>整个页面由顶部的标题栏+可滑动的body组成</p>
<pre><code>&lt;view class=&quot;stv-container&quot;&gt;
  &lt;view class=&quot;tab-bar&quot;&gt;
    &lt;view wx:for=&quot;{{titles}}&quot; wx:key=&quot;unique&quot; data-index=&quot;{{index}}&quot; bindtap=&quot;handlerTabTap&quot; class=&quot;tab {{activeIndex==index?'tab-active':''}}&quot; style=&quot;width: {{stv.windowWidth/titles.length}}px&quot;&gt;
        &lt;text&gt;{{item}}&lt;/text&gt;
    &lt;/view&gt;
    &lt;view style=&quot;width: {{stv.lineWidth}}px; left: {{stv.offset/titles.length}}px&quot; class=&quot;under-line {{!stv.tStart? 'withAnimate': ''}}&quot;&gt;&lt;/view&gt;
  &lt;/view&gt;
  &lt;view style=&quot;padding: 15px; height: 100%; margin-top: 30px; background-color: #fafafa&quot;&gt;
    &lt;swiper duration=&quot;500&quot; bindchange=&quot;swiper&quot; current=&quot;{{activeIndex}}&quot; style=&quot;height: 100%&quot;&gt;
        &lt;block wx:for=&quot;{{contents}}&quot; wx:key=&quot;*this&quot;&gt;
            &lt;swiper-item&gt;
                &lt;view style=&quot;height: 100%&quot;&gt;
                    &lt;text&gt;{{contents[index]}}&lt;/text&gt;
                &lt;/view&gt;
            &lt;/swiper-item&gt;
        &lt;/block&gt;
    &lt;/swiper&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre><h3 id="建立wxjs"><a href="#建立wxjs" class="headerlink" title="建立wxjs"></a>建立wxjs</h3><p>  以上代码是整个页面的布局， 可滑动的body我们用swiper组成，接下来是组成页面的数据滑动或者点击的方法，代码如下：</p>
<pre><code>// pages/newMusic/index.js
Page({
  /**
  * 页面的初始数据
  */
  data: {
    activeIndex: 0,
    stv: {
      windowWidth: 0,
      lineWidth: 0,
      offset: 0,
      tStart: false
    },
    titles: [&apos;文字一&apos;, &apos;文字二&apos;, &apos;文字三&apos;, &apos;文字四&apos;],
    contents: [
      &quot;小时候，我穿着老爸的直筒袜，想象着我在大西部论坛球馆，投中制胜球的样子，我就深深明白一件事，我爱上了篮球，我爱你如此深以致贡献所有， 我的思想和身体， 我的精神和灵魂， 六岁开始， 我就深爱着你&quot;,
      &quot;从未想到过结束，我只看到自己，在这条路上奔跑到尽头，所以我不停地跑，在 每个球馆我全力奔跑，为你争取每次机会，你要求我拼尽所有，所以我奉上真心，因为这里包含太多，我带着汗水和伤痛，不仅因为挑战&quot;,
      &quot;而是你在召唤我，我为你奉献所有，因为你也赠予我全部，因为篮球，我感到是一个鲜活的人，你让6岁孩子实现湖人梦，为此我将永远爱你，但我不能再迷恋你，这个赛季是我仅能给，心还能继续承受打击，意志也还能被碾磨&quot;,
      &quot;但身体知道是时候说再见，我已经准备让你离开，现在只是想让你知道，我们能永远珍藏着每段时光，无论是好的，还是坏的，我们已贡献给彼此，所有的全部，无论接下来我会做什么，我都会是那个孩子，穿着老爸直筒袜，瞄准角落里的垃圾桶&quot;
      ]
    },

  /**
  * 生命周期函数--监听页面加载
  */
  onLoad: function (options) {},

  bodyChange: function(e) {
    console.log(e.target.dataset.value);
    this.setData({
      activeIndex: e.target.dataset.value
    });
  },
  swiper: function(e){
    this._updateSelectedPage(e.detail.current);
  },
  bodyscroll:function(e){
    console.log(e);
  },
  _updateSelectedPage(page) {
    let {titles, stv, activeIndex} = this.data;
    activeIndex = page;
    this.setData({activeIndex: activeIndex})
    stv.offset = stv.windowWidth*activeIndex;
    this.setData({stv: this.data.stv})
  },
  handlerTabTap(e) {
    this._updateSelectedPage(e.currentTarget.dataset.index);
  }
});
</code></pre><h3 id="建立WXSS"><a href="#建立WXSS" class="headerlink" title="建立WXSS"></a>建立WXSS</h3><p>  以下内容为页面样式：</p>
<pre><code>.stv-container {
  height: 100%
}
.withAnimate {
  transition: all 100ms ease;
  -webkit-transform: translate3d(0, 0, 0);
  -moz-transform: translate3d(0, 0, 0);
  -ms-transform: translate3d(0, 0, 0);
  transform: translate3d(0, 0, 0);
  -webkit-backface-visibility: hidden;
  -moz-backface-visibility: hidden;
  -ms-backface-visibility: hidden;
  backface-visibility: hidden;
  -webkit-perspective: 1000;
  -moz-perspective: 1000;
  -ms-perspective: 1000;
  perspective: 1000;
}
.stv-container .tab-bar {
  position: fixed;
  display: flex;
  font-size: 30rpx;
  color: #666666;
  background-color: #fff;
  z-index: 999;
  top: 0;
}
.stv-container .tab-bar .tab-active {
  color: #2d80ff;
}
.stv-container .tab-bar .tab {
  display: flex;
  align-items: center;
  justify-content: center;
  padding-top: 16rpx;
  padding-bottom: 20rpx;
}
.stv-container .tab-bar .under-line {
  position: absolute;
  bottom: 0;
  height: 6rpx;
  background-color: #2d80ff;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">choleece</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">choleece</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
