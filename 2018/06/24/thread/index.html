<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="1. 什么是线程？线程是操作系统能够进行运算调度的最小单位，它包含在进程中，是进程中的实际运作单位，可以使用多线程对运算进行提速。 2. 什么是线程安全和线程不安全？通俗的说：加锁就是线程安全的，不加锁就是线程不安全的。 线程安全线程安全：就是多线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，知道该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程知识面试汇总">
<meta property="og:url" content="https://www.choleece.cn/2018/06/24/thread/index.html">
<meta property="og:site_name" content="choleece">
<meta property="og:description" content="1. 什么是线程？线程是操作系统能够进行运算调度的最小单位，它包含在进程中，是进程中的实际运作单位，可以使用多线程对运算进行提速。 2. 什么是线程安全和线程不安全？通俗的说：加锁就是线程安全的，不加锁就是线程不安全的。 线程安全线程安全：就是多线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，知道该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-26T23:47:08.805Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程知识面试汇总">
<meta name="twitter:description" content="1. 什么是线程？线程是操作系统能够进行运算调度的最小单位，它包含在进程中，是进程中的实际运作单位，可以使用多线程对运算进行提速。 2. 什么是线程安全和线程不安全？通俗的说：加锁就是线程安全的，不加锁就是线程不安全的。 线程安全线程安全：就是多线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，知道该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.choleece.cn/2018/06/24/thread/"/>





  <title>多线程知识面试汇总 | choleece</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">choleece</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">blog</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.choleece.cn/2018/06/24/thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="choleece">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="choleece">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">多线程知识面试汇总</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-24T22:14:51+08:00">
                2018-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1. 什么是线程？"></a>1. 什么是线程？</h3><p>线程是操作系统能够进行运算调度的最小单位，它包含在进程中，是进程中的实际运作单位，可以使用多线程对运算进行提速。</p>
<h3 id="2-什么是线程安全和线程不安全？"><a href="#2-什么是线程安全和线程不安全？" class="headerlink" title="2. 什么是线程安全和线程不安全？"></a>2. 什么是线程安全和线程不安全？</h3><p>通俗的说：加锁就是线程安全的，不加锁就是线程不安全的。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全：就是多线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，知道该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p>
<p>一个线程安全的计数器类的同一个实例对象在被对多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全。<br>Vector是用同步方法来实现线程安全的，而和它相似的ArrayList不是线程安全的。</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p>
<h3 id="3-什么是自旋锁？"><a href="#3-什么是自旋锁？" class="headerlink" title="3. 什么是自旋锁？"></a>3. 什么是自旋锁？</h3><p>自旋锁是SMP架构中的一种low-level的同步机制。</p>
<p>当线程A想要获取一把自旋锁而该所又被其他线程持有时，线程A会在一个循环中自旋以检测锁是不是已经可以可用了。</p>
<h4 id="自旋锁需要注意："><a href="#自旋锁需要注意：" class="headerlink" title="自旋锁需要注意："></a>自旋锁需要注意：</h4><ul>
<li>由于自旋不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在那里自旋，这就会浪费CPU时间。</li>
<li>持有自旋锁的线程在sleep之前应该释放自旋锁以便其他线程可以获得自旋锁锁。</li>
</ul>
<p>自旋锁的实现：<br>目前的JVM实现自旋锁会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyWaitNotify &#123;</span><br><span class="line">    MonitorObject myMonitorObject = new MonitorObject();</span><br><span class="line">    boolean wasSignalled = false;</span><br><span class="line"></span><br><span class="line">    public void doWait() &#123;</span><br><span class="line">        synchronized(myMonitorObject) &#123;</span><br><span class="line">            while(!wasSignalled) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    myMoniorObject.wait();</span><br><span class="line">                &#125; catch(InterruptedException e) &#123;...&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // clear singal and continue running..</span><br><span class="line">             wasSinnalled = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doNotify() &#123;</span><br><span class="line">        synchronized(myMonitorObject) &#123;</span><br><span class="line">            wasSignalled = true;</span><br><span class="line">            myMonitorObject.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-什么是Java内存模型？"><a href="#4-什么是Java内存模型？" class="headerlink" title="4. 什么是Java内存模型？"></a>4. 什么是Java内存模型？</h3><p>Java内存模型描述了在多线程中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了”程序中的变量”和”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来做正确实现以上事情。</p>
<p>Java包含了几个语音级别的关键字，包括：volatile, final以及synchronized，目的是为了帮助程序员向编译器描述一个程序的并发需求。Java内存模型定义了volatile和synchronized行为，更重要的是保证了同步的Java程序在所有的处理器架构下面都能正确的运行。</p>
<p>“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致对。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后边会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到这个操作结果，这反映了换成的影响。</p>
<p>此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其能在最佳顺序的情况下执行操作。在内存模型的限定之内，我们能够获取更高的性能。<br>看下面代码展示的一个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class Recording &#123;</span><br><span class="line">    int x = 0, y = 0;</span><br><span class="line"></span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        int r1 = y;</span><br><span class="line">        int r2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看在两个并发线程中执行这段代码，读取Y变量会得到2个这个🈯️值。因为这个写入比写到X变量更晚一些，程序员可能认为读取X变量将肯定得到1，但是，写入操作可能被重排序过，如果重排序发生了，那么就能发生对Y变量的写入操作，读取两个变量的操作紧随其后，而且写入到X这个操作能发生。程序的结果可能是r1变量的值是2，但是r2变量的值为0</p>
<p>但是面试官，有时候不这么认为，认为就是JVM内存结构<br>JVM内存结构主要有三块：对内存、方法区和栈。</p>
<p>堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间，From Survivor空间、To Survivor空间，默认情况下年轻代按照8:1:1的比例来分配；方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法去还有一个别名Non-Heap(非堆)；栈又分为Java虚拟机栈和本地方法栈主要用于方法的执行。</p>
<h4 id="Java的JVM的内存可分为3个区：堆（heap）、栈-stack-和方法区（method）"><a href="#Java的JVM的内存可分为3个区：堆（heap）、栈-stack-和方法区（method）" class="headerlink" title="Java的JVM的内存可分为3个区：堆（heap）、栈(stack)和方法区（method）"></a>Java的JVM的内存可分为3个区：堆（heap）、栈(stack)和方法区（method）</h4><p>Java堆（Java Heap）</p>
<ul>
<li>可通过参数 -Xms和Xmx设置</li>
</ul>
<ol>
<li>Java堆是被所有线程共享，是Java虚拟机所管理的内存中最大的一块Java堆在虚拟机启动时创建。</li>
<li>Java堆唯一堆目的是存放对象实例，几乎所有的对象实例和数组都在这里。</li>
<li>Java堆为了便于更好堆回收和分配内存，可以细分为：新生代和老年代；在细致一点有Eden空间、From Survivor空间、To Survivor区。<br> a. 新生代：包括Eden区、From Survivor区、To Survivor区、系统默认大小Eden : Survivor = 8 : 1;<br> b. 老年代：在年轻代经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中，因此，可以认为老年代中存放的都是一些生命周期较长的对象。</li>
<li>Survivor空间等Java堆可以处在物理上不连续的内存共建中，只要逻辑上是连续的即可。</li>
</ol>
<h5 id="据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。"><a href="#据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。" class="headerlink" title="据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。"></a>据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。</h5><p>本地方法栈</p>
<ul>
<li>可通过参数 栈容量可由-Xss设置</li>
</ul>
<ol>
<li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。</li>
<li>本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。</li>
</ol>
<p>方法区（Method Area）<br>可通过参数-XX:MaxPermSize设置</p>
<ol>
<li>线程共享内粗区域，用于存储已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也称为持久代（Permanent Generation）</li>
<li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫Non-Heap（非堆），目的应该是与Java堆区分开来</li>
<li>如何实现方法区，属于虚拟机的实现细节，不受虚拟机约束规范。</li>
<li>方法去主要方法Java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收，但并不是没有垃圾回收。</li>
<li>方法区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</li>
<li>运行时常量，也是方法区的一部分，虚拟机加载class后把常量池中的数据放入运行时常量池。</li>
</ol>
<p>运行时常量池</p>
<p>JDK1.6之前字符串常量池位于方法区之中。JDK1.7字符串常量池已经被挪到堆之中。<br>可通过参数-XX:PermSize和–XX:MaxPermSize设置</p>
<ul>
<li>常量池（Constant Pool ）：常量池数据编译期被确定，是Class文件中的一部分。存储了类、方法、接口中的常量，当然也包括字符串常量。</li>
<li>字符串池/字符串常量池（String Pool）/（String Constant Pool）：是常量池中一部分，存储编译期类中产生的字符串类型数据。</li>
<li>运行时常量池（Runtime Constant Pool）:方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入到运行时常量池。常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型。</li>
</ul>
<ol>
<li>常量池中主要存放两大类常量：字面量（Literal）和符号饮用（Symbolic Reference）。</li>
<li>字面量：文本字符串、声明为final的常量值等。</li>
<li>符号引用：类和接口的完全限定名（Full Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。</li>
</ol>
<p>直接内存</p>
<p>可通过-XX:MaxDirectMemory指定，如果不指定，则默认与Java堆的最大值（-Xmx）一样。</p>
<ul>
<li>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。</li>
</ul>
<p>总结的简单一点<br>Java堆（Java Heap）<br>可通过参数-Xms 和 -Xmx设置</p>
<ol>
<li>Java堆是被所有线程共享，是Java虚拟机所管理的内存中最大的一块，Java堆在虚拟机启动后创建</li>
<li>Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都放在这里</li>
<li><p>Java堆为了更好的回收和分配内存，可以细分为新生代和老年代；再细致一点分为Eden空间，From Survivor空间，To Survivor空间。</p>
<ul>
<li>新生代：包括Eden区、From Survivor区、To Survivor区，系统默认大小为Eden:Survivor=8：1。</li>
<li>老年代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</li>
</ul>
</li>
</ol>
<p>Java虚拟机栈（Stack）<br>可通过参数栈帧是方法运行期的基础数据结构，栈容量可由-Xss设置</p>
<ol>
<li>Java虚拟机栈是线程私有的，它的生命周期与线程相同。</li>
<li>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</li>
<li>虚拟机栈是执行Java方法的内存模型（也就是字节码）服务：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>
</ol>
<p>方法区（Method Area）<br>可通过-XX:MaxPermSize设置</p>
<ol>
<li>线程共享内存区域，用于已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也被称为持久代（Permanent Generation）</li>
<li>方法区主要存放Java类定义信息，与垃圾回收关系不大，方法区可以现在不实现垃圾回收，但不是没有垃圾回收。</li>
<li>方法区域的内存回收目标只要是针对常量池和堆类型的卸载。</li>
<li><p>运行时常量池，也是方法区的一部分，虚拟机加载Class后把常量池中国呢的数据放入运行时常量池。</p>
</li>
<li><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><p>CAS（compare and swap）的缩写，中文翻译成比较与交换。</p>
</li>
</ol>
<p>CAS不通过JVM，直接利用Java本地方法JNI（Java Native Interface为Java本地调用），直接调用CPU的cmpxchg指令。</p>
<p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法，实现院子操作。其他远离操作都是利用类似的特性完成的。</p>
<p>整个java.util.concurrent都是建立在CAS之上的，因此对于synchronized的阻塞算法，J.U.C在性能上有来了很大的提升。</p>
<p>CAS是项乐观锁技术，当多个线程都尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<h4 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h4><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B，当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<h4 id="CAS优点"><a href="#CAS优点" class="headerlink" title="CAS优点"></a>CAS优点</h4><p>确保对内存的读-改-写操作都是原子操作执行</p>
<h4 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h4><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>使用CAS在线程冲突严重时，会大幅降低程序性能；CAS只适合于线程冲突较少的情况使用。</li>
<li>synchronized在JDK1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ol>
<h3 id="6-什么是乐观锁和悲观锁？"><a href="#6-什么是乐观锁和悲观锁？" class="headerlink" title="6. 什么是乐观锁和悲观锁？"></a>6. 什么是乐观锁和悲观锁？</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以说synchronize是悲观锁。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁（Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回用户错误的信息，让用户决定如何去做。</p>
<h3 id="6-什么是原子操作？在Java-Concurrency-API中有哪些原子类（atomic-classes）？"><a href="#6-什么是原子操作？在Java-Concurrency-API中有哪些原子类（atomic-classes）？" class="headerlink" title="6. 什么是原子操作？在Java Concurrency API中有哪些原子类（atomic classes）？"></a>6. 什么是原子操作？在Java Concurrency API中有哪些原子类（atomic classes）？</h3><p>原子操作是指一个不受其他操作影响的操作任何单元。原子操作是在多线程环境下避免数据不一致必须的手段</p>
<p>i++并不是一个原子操作，所以当一个线程读取它的值并+1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术做到这一点。</p>
<p>在JDK1.5之后，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p>
<h3 id="7-什么是Executors框架？"><a href="#7-什么是Executors框架？" class="headerlink" title="7. 什么是Executors框架？"></a>7. 什么是Executors框架？</h3><p>Executor框架同java.util.concurrent.Executor接口在Java5中被引入。</p>
<p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务框架。</p>
<p>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。</p>
<p>利用Executor框架可以非常方便的创建一个线程池，</p>
<p>Java通过Executors提供四种线程池，分别为：</p>
<p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需求，可灵活回收空闲线程，若无可回收，则创建新线程。</p>
<p>newFixedThreadPool创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>newSingleThreadExecutor创建一个但线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行。</p>
<h3 id="8-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#8-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="8.什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"></a>8.什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>JDK7提供了7个阻塞队列。（也属于并发容器）</p>
<ol>
<li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDueue：一个由链表结构组成的双向阻塞队列。</li>
</ol>
<h4 id="什么是阻塞队列？"><a href="#什么是阻塞队列？" class="headerlink" title="什么是阻塞队列？"></a>什么是阻塞队列？</h4><p>阻塞队列是一个在队列基础上又支持了两个附加操作的队列。</p>
<p>2个附加操作：</p>
<p>支持阻塞的插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>支持阻塞的移除方法：队列空时，获取元素的线程会等待队列变为非空。</p>
<p>阻塞队列的应用场景</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。简而言之，阻塞队列是生产者用来存放元素、消费者用来获取元素的容器。</p>
<p>Java里的阻塞队列，如下</p>
<ol>
<li>ArrayBlockingQueue 数组结构组成的有界阻塞队列。</li>
</ol>
<p>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程队列访问的顺序是不能保证线程公平（即先阻塞，先插入的）。</p>
<ol>
<li>LinkedBlockingQueue一个由链表组成的有界阻塞队列</li>
</ol>
<p>此队列按照先进消除的原则对元素进行排序</p>
<ol>
<li><p>PriorityBlockingQueue支持优先级的无界阻塞队列</p>
</li>
<li><p>DelayQueue支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素</p>
</li>
<li><p>SynchronousQueue不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列</p>
</li>
<li><p>LinkedTransferQueue由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法。</p>
</li>
</ol>
<p>transfer方法</p>
<p>如果当前有消费者正在等待接受元素（take或者待时间限制的poll方），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费力才返回。</p>
<p>tryTransfer方法</p>
<p>用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。</p>
<ol>
<li>LinkedBlockingDeque链表结构的双向阻塞队列，优势在于多线程入队时，减少一半的竞争。</li>
</ol>
<p>如何使用阻塞队列来实现生产者-消费者模型？</p>
<p>通知模式实现：所谓通知模式，及时当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费里一个队列中的元素后，会通知生产者当前队列可用。</p>
<p>使用BlockingQueue解决生产者消费者问题</p>
<p>为什么BlockingQueue适合解决生产者消费者问题</p>
<p>任何有效的生产者-消费者问题解决方案通过都是通过控制生产者put()方法（生产资源）和消费者take()方法（消费资源）的调用来实现的，一旦你实现了对方法的阻塞控制，那么你就将解决该问题。</p>
<p>Java通过BlockingQueue提供了开箱即用的支持来控制这些方法的调用（一个线程创建资源，另一个消费资源）。Java.util.concurrent包下的BlockingQueue接口是一个线程安全的可用于存取对象的队列。</p>
<p>BlockingQueue是一种数据结构，支持一个线程往里存资源，另一个线程从里取资源。这正式解决生产者消费者问题所需要的，那么让我们开始解决该问题吧。</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>以下代码用于生产者线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 生产者</span><br><span class="line"> *</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class Producer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    protected BlockingQueue&lt;Object&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    public Producer(BlockingQueue&lt;Object&gt; blockingQueue) &#123;</span><br><span class="line">        this.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Object justProduced = getResource();</span><br><span class="line">                blockingQueue.put(justProduced);</span><br><span class="line">                System.out.println(&quot;生产者资源队列大小==&quot; + blockingQueue.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;生产者 写 中断&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object getResource() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;生产者 读 中断&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<p>以下代码用于消费者线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消费者</span><br><span class="line"> *</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    protected BlockingQueue&lt;Object&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    public Consumer(BlockingQueue&lt;Object&gt; blockingQueue) &#123;</span><br><span class="line">        this.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Object obj = blockingQueue.take();</span><br><span class="line">                System.out.println(&quot;消费者队列大小：&quot; + blockingQueue.size());</span><br><span class="line">                take(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">            System.out.println(&quot;消费者 中断&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void take(Object obj) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;消费者 读 中断&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;消费对象：&quot; + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试该解决方案是否运行正常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 启动线程</span><br><span class="line"> *</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class PCExample &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int proNum = 4, cusNum = 3;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;Object&gt; blockingQueue = new LinkedBlockingQueue&lt;Object&gt;(5);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; proNum; i++) &#123;</span><br><span class="line">            new Thread(new Producer(blockingQueue)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; cusNum ; i++) &#123;</span><br><span class="line">            new Thread(new Consumer(blockingQueue)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;在我之后就结束了&quot;);</span><br><span class="line"></span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">主线程</span><br><span class="line">生产者资源队列大小==3</span><br><span class="line">消费者队列大小：3</span><br><span class="line">消费者队列大小：2</span><br><span class="line">消费者队列大小：1</span><br><span class="line">生产者资源队列大小==4</span><br><span class="line">生产者资源队列大小==2</span><br><span class="line">生产者资源队列大小==3</span><br><span class="line">生产者资源队列大小==2</span><br><span class="line">消费对象：java.lang.Object@6ca1879</span><br><span class="line">消费对象：java.lang.Object@24e07882</span><br><span class="line">消费对象：java.lang.Object@1da459ca</span><br><span class="line">消费者队列大小：3</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">生产者资源队列大小==4</span><br><span class="line">生产者资源队列大小==3</span><br><span class="line">消费者队列大小：2</span><br><span class="line">生产者资源队列大小==3</span><br><span class="line">生产者资源队列大小==4</span><br><span class="line">消费对象：java.lang.Object@2a27926e</span><br><span class="line">消费对象：java.lang.Object@80df6d0</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费对象：java.lang.Object@199bcea6</span><br><span class="line">消费者队列大小：3</span><br><span class="line">生产者资源队列大小==4</span><br><span class="line">消费对象：java.lang.Object@c327309</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费对象：java.lang.Object@2e1813f2</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@5c9953f1</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@6b1a9855</span><br><span class="line">消费对象：java.lang.Object@4930fceb</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费对象：java.lang.Object@52da10a1</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费者队列大小：5</span><br><span class="line">消费对象：java.lang.Object@1fef2c64</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@4c99d9dc</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@6d0f6939</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@7833f23f</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@5a3b96c3</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@2aa674c0</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@67067c0b</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@345289f5</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@3cb6acbe</span><br><span class="line">消费者队列大小：4</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@291f03a4</span><br><span class="line">消费者队列大小：5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">消费对象：java.lang.Object@b35671a</span><br><span class="line">消费对象：java.lang.Object@3eebec91</span><br><span class="line">消费者队列大小：4</span><br><span class="line">消费者队列大小：5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">生产者资源队列大小==5</span><br><span class="line">在我之后就结束了</span><br></pre></td></tr></table></figure>
<p>从输出结果中，我们可以发现队列大小永远不会超过5，消费者线程消费了生产者生产的资源。</p>
<h3 id="9-什么是Callable和Future？"><a href="#9-什么是Callable和Future？" class="headerlink" title="9. 什么是Callable和Future？"></a>9. 什么是Callable和Future？</h3><p>Callable和Future是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到他们。Callable用于产生结果，Future用于获取结果。</p>
<p>Callable接口使用泛型去定义它的返回类型，Executors类提供类一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决类这个问题。</p>
<p>在线程池提交Callable任务后返回类一个Future对象，使用它可以直到Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。</p>
<p>代码示例</p>
<p>Callable是一个结构，它只包含一个cal()方法。Callable是一个返回结果并且可能抛出异常的任务。</p>
<p>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似与Runnable的run()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * callable &amp; future</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class CallableFutureTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        System.out.println(&quot;start main thread&quot;);</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">        // 新建一个callable任务，并将其提交到ExecutorService，将返回一个描述任务情况的Future</span><br><span class="line">        Callable&lt;String&gt; callable = new Callable&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                System.out.println(&quot;start new thread&quot;);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                System.out.println(&quot;end new thread&quot;);</span><br><span class="line">                return &quot;我是返回的内容&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = service.submit(callable);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        String retn = future.get();</span><br><span class="line">        // 关闭线程池</span><br><span class="line">        service.shutdown();</span><br><span class="line">        System.out.println(retn + &quot;------end main thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start main thread</span><br><span class="line">start new thread</span><br><span class="line">end new thread</span><br><span class="line">我是返回的内容------end main thread</span><br></pre></td></tr></table></figure>
<h3 id="10-什么是FutureTask"><a href="#10-什么是FutureTask" class="headerlink" title="10. 什么是FutureTask?"></a>10. 什么是FutureTask?</h3><p>FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。另外，FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。</p>
<ol>
<li>执行多任务计算</li>
</ol>
<p>FutureTask执行多任务计算的使用场景</p>
<p>利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，当主线程需要子线程的计算结果时，再异步获取子线程的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package cn.choleece.threads;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 执行多任务计算</span><br><span class="line"> * @author choleece</span><br><span class="line"> * @date 2018/6/25</span><br><span class="line"> */</span><br><span class="line">public class FutureTaskForMultiCompute &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FutureTaskForMultiCompute inst = new FutureTaskForMultiCompute();</span><br><span class="line"></span><br><span class="line">        // 创建任务集合</span><br><span class="line">        List&lt;FutureTask&lt;Integer&gt;&gt; taskList = new ArrayList&lt;FutureTask&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 创建线程池</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(5);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            // 传入callable对象创建FutureTask对象</span><br><span class="line">            FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(inst.new ComputeClass(i, &quot;&quot; + i));</span><br><span class="line">            taskList.add(ft);</span><br><span class="line">            // 提交给线程池执行任务，也可用exec的invokeAll(taskList)方法一次性提交素有任务</span><br><span class="line">            exec.submit(ft);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;所有计算任务提交完毕，主线程接着干其他的事情&quot;);</span><br><span class="line"></span><br><span class="line">        // 开始统计各计算线程的结果</span><br><span class="line">        Integer totalResult = 0;</span><br><span class="line">        for (FutureTask&lt;Integer&gt; ft : taskList) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // FutureTask的get()方法会自动阻塞，直到获取计算结果为止</span><br><span class="line">                totalResult += ft.get();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        System.out.println(&quot;多任务计算后的总结果是：&quot; + totalResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class ComputeClass implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private Integer result = 0;</span><br><span class="line"></span><br><span class="line">        private String taskName = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        public ComputeClass(Integer result, String taskName) &#123;</span><br><span class="line">            this.result = result;</span><br><span class="line">            this.taskName = taskName;</span><br><span class="line">            System.out.println(&quot;生成子线程任务：&quot; + taskName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getTaskName() &#123;</span><br><span class="line">            return taskName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            // 休眠5秒钟，观察主线程行为，预期的结果是主线程会继续执行，到要取到FutureTask的结果时等待直至完成</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            System.out.println(&quot;子线程计算任务： &quot; + taskName + &quot; 计算完成&quot;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">生成自线程任务：0</span><br><span class="line">生成自线程任务：1</span><br><span class="line">生成自线程任务：2</span><br><span class="line">生成自线程任务：3</span><br><span class="line">生成自线程任务：4</span><br><span class="line">生成自线程任务：5</span><br><span class="line">生成自线程任务：6</span><br><span class="line">生成自线程任务：7</span><br><span class="line">生成自线程任务：8</span><br><span class="line">生成自线程任务：9</span><br><span class="line">所有计算任务提交完毕，主线程接着干其他的事情</span><br><span class="line">子线程计算任务： 0 计算完成</span><br><span class="line">子线程计算任务： 2 计算完成</span><br><span class="line">子线程计算任务： 1 计算完成</span><br><span class="line">子线程计算任务： 3 计算完成</span><br><span class="line">子线程计算任务： 4 计算完成</span><br><span class="line">子线程计算任务： 6 计算完成</span><br><span class="line">子线程计算任务： 8 计算完成</span><br><span class="line">子线程计算任务： 7 计算完成</span><br><span class="line">子线程计算任务： 5 计算完成</span><br><span class="line">子线程计算任务： 9 计算完成</span><br><span class="line">多任务计算后的总结果是：49545</span><br></pre></td></tr></table></figure></p>
<ol>
<li>高并发环境下</li>
</ol>
<p>FutureTask在高并发环境下确保任务只执行一次</p>
<p>在很多高并发环境下，往往我们只需要某些任务只执行一次。这种使用场景FutureTask的特性恰好能胜任。举一个例子，假设有一个带key的连接池，当key存在时，即直接返回key对应的对象；当key不存在时，则创建链接。对于这样的应用场景，通常采用的方法为使用一个Map对象来存储key和连接池对应的对应刮洗，典型的代码如下面所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Connection&gt; connectionPool = new HashMap&lt;String, Connection&gt;();</span><br><span class="line">private ReentrantLock lock = new ReentrantLock();</span><br><span class="line">public Conncetion getConnection(String key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        if (connectionPool.containsKey(key)) &#123;</span><br><span class="line">            return connectionPool.get(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 创建connection</span><br><span class="line">            Connection coon = createConnection();</span><br><span class="line">            connectionPool.put(key, coon);</span><br><span class="line">            return coon;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        loco.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建connection</span><br><span class="line"></span><br><span class="line">private Connection createConnection() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们通过枷锁确保高并发环境下的线程安全，也确保了connection 只创建一次，然而确牺牲了性能。改用ConcurrentHash的情况下，几乎可以避免枷锁的操作，性能大大提高，但是在高并发的情况下有可能出现Connection被创建多次的现象。这时最需要解决的问题就是当key不存在时，创建Connection的动作能放在connectionPool之后执行，这正式FutureTask发挥作用的时机，基于ConcurrentHashMap和FutureTask的改造代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private ConcurrentHashMap&lt;String, FutureTask&lt;Connection&gt;&gt; connectionPool = new ConcurrentHashMap&lt;String, FutureTask&lt;Connection&gt;&gt;();</span><br><span class="line"></span><br><span class="line">public Connection getConnection(String key) throws Exception &#123;</span><br><span class="line">    FutureTask&lt;Connection&gt; connectionTask = connectionPool.get(key);</span><br><span class="line">    if (connectionTask != null) &#123;</span><br><span class="line">        return connectionTask.get();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Callable&lt;Connection&gt; callable = new Callable&lt;Connection&gt;() &#123;</span><br><span class="line">            @override</span><br><span class="line">            public Connection call() throws Exception &#123;</span><br><span class="line">                return createConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Connection&gt; newTask = new FutureTask&lt;Connection&gt;(callable);</span><br><span class="line">        connectionTask = connectionPool.put(key, newTask);</span><br><span class="line">        if (connectionTask != null) &#123;</span><br><span class="line">            connectionTask = newTask;</span><br><span class="line">            connectionTask.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return connectionTask.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建connection</span><br><span class="line">private Connection createConnection() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过这样的改造，可以避免由于并发带来的多次创建链接及锁的出现。</p>
<h3 id="11-什么是同步容器和并发容器的实现？"><a href="#11-什么是同步容器和并发容器的实现？" class="headerlink" title="11. 什么是同步容器和并发容器的实现？"></a>11. 什么是同步容器和并发容器的实现？</h3><p>一、同步容器</p>
<p>主要代表有Vector和HashTable，以及Collections.sychronizedXxx等。锁的粒度为当前对象整体。迭代器是及时失败的，即在迭代过程中发现被修改，就会抛出ConcurrentModificationException。</p>
<p>二、并发容器</p>
<p>主要有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。锁的粒度是分散的、细粒度的，即读和写使用不同的锁。迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</p>
<p>JDK7 ConcurrentHashMap</p>
<p>采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问；</p>
<p>JDK8 ConcurrentHashMap</p>
<p>采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问；</p>
<p>三、阻塞队列</p>
<p>主要有LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue(Comparable、Comparator)、SynchronousQueue。提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。适用于生产者、消费者（线程池和工作队列-Executor）,同时也是同步容器。</p>
<p>四、双端队列</p>
<p>主要代表有ArrayDeque和LinkedBlockingDeque。意义：正如阻塞对垒适用于生产者消费者模式，双端队列同样适用于另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。如果一个消费者完成了自己的双端队列的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它就从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。适用于：网页爬虫等任务中。</p>
<p>五、比较及适用场景</p>
<p>如果不需要阻塞队列，优先选择ConcurrentLinkedQueue；如果需要阻塞队列，队列的大小固定优先选择ArrayBlockingQueue，队列的大小不固定优先选择LinkedBlockingQueue；如果需要队列进行排序，选择PriorityBlockingQueue；如果需要一个快速交换的队列，选择SynchronousQueue; 如果需要对队列中的元素进行延时操作，则选择DelayQueue。</p>
<h3 id="12-什么是多线程？优缺点？"><a href="#12-什么是多线程？优缺点？" class="headerlink" title="12. 什么是多线程？优缺点？"></a>12. 什么是多线程？优缺点？</h3><p>什么是多线程？</p>
<p>多线程：是指从软件或者硬件上实现多个线程的并发技术。</p>
<p>多线程的好处：</p>
<ol>
<li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的下载</li>
<li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好</li>
</ol>
<p>多线程的缺点：</p>
<ol>
<li>大量的线程降低代码的可读性</li>
<li>更多的线程需要更多的内存空间</li>
<li>当多个线程对同一个资源出现争夺时候要注意线程安全的问题。</li>
</ol>
<h3 id="13-什么是多线程的上下文切换？"><a href="#13-什么是多线程的上下文切换？" class="headerlink" title="13. 什么是多线程的上下文切换？"></a>13. 什么是多线程的上下文切换？</h3><p>即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间。因为时间片非常短，所以CPU通过不停的切换线程执行，让我们感觉多个线程同时执行，时间片一般是几十毫秒</p>
<p>上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体为止以便之后继续运行。</p>
<p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态。</p>
<ul>
<li>从任务保存到再加载的过程就是一次上下文切换</li>
</ul>
<h3 id="14-ThreadLocal的设计理念和作用？"><a href="#14-ThreadLocal的设计理念和作用？" class="headerlink" title="14. ThreadLocal的设计理念和作用？"></a>14. ThreadLocal的设计理念和作用？</h3><p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量</p>
<p>ThreadLocal</p>
<p>如何创建ThreadLocal变量：</p>
<pre><code>private ThreadLocal myTHreadLocal = new ThreadLocal();
</code></pre><p>通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，它们仍然无法访问到对方的值。</p>
<p>如何访问ThreadLocal变量</p>
<p>一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值：</p>
<pre><code>myTHreadLocal.set(&quot; A thread local value&quot;);
</code></pre><p>可以通过下面方法读取保存在ThreadLocal变量中的值：</p>
<pre><code>String threadLocalValue = (String) myThreadLocal.get();
</code></pre><p>get()方法返回一个Object对象，set()对象需要传入一个Object类型的参数。</p>
<p>为ThreadLocal指定泛型类型</p>
<pre><code>public static ThreadLocal&lt;String&gt; myThreadLocal = new ThreadLocal&lt;String&gt;();
</code></pre><p> 我们可以创建一个执行泛型的ThreadLocal对象，这样我们就不需要每次对使用get()方法返回的值作强制类型转换了。</p>
<h3 id="15-ThreadPool-线程池-用法与优势？"><a href="#15-ThreadPool-线程池-用法与优势？" class="headerlink" title="15. ThreadPool(线程池)用法与优势？"></a>15. ThreadPool(线程池)用法与优势？</h3><p> 为什么要用线程池：</p>
<ol>
<li><p>减少创建和销毁线程的次数，每个工作线程可以被重复利用，可执行多个任务。</p>
</li>
<li><p>可以根据系统的承受能力，调整线程池中工作线程线程数目，防止因为消耗过多的内存，而把服务搞死机</p>
</li>
<li><p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p>new Thread 缺点</p>
</li>
<li><p>每次new Thread新建对象性能差</p>
</li>
<li><p>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或OOM</p>
</li>
<li><p>缺乏更多功能，如定时执行，定期执行，线程中断</p>
<p>ThreadPool优点</p>
<p>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</p>
<p>可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而让服务器死机</p>
</li>
</ol>
<ul>
<li>减少在创建和销毁线程上所画的时间以及系统资源的开销</li>
<li><p>如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存</p>
<p>Java提供的四种线程池的好处在于：</p>
</li>
</ul>
<ol>
<li>重用存在的线程，减少对象创建、销毁的开销，提高性能。</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免阻塞。</li>
<li><p>提供定时执行，定期执行，单线程，并发书控制等功能。</p>
<p>比较重要的几个类：</p>
<p>| 类 | 描述 |<br>| :— | :—-: |<br>| ExecutorService | 真正的线程池接口。 |<br>| ScheduledExecutorService    | 能和Timer/TimerTask类似，解决哪些需要任务重复执行的问题      |<br>| ThreadPoolExecutor   | ExecutorService的默认实现  |<br>| ScheduledThreadPoolExecutor  | 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现|。</p>
<p>要配置一个线程池是比较复杂的，尤其是对线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供类一些静态工厂，生成一些常用的线程池。</p>
<p>Executors提供四种线程池</p>
<p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可回收空闲线程，若无可回收，则创建新线程。</p>
<p>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列总等待。</p>
<p>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>newScheduledThreadPool创建一个单线程化的线程池，它只会用唯一的工作线程来保证执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行。</p>
<p>一般都不用Executors提供的线程创建方式</p>
<p>使用ThreadPoolExecutor创建线程池</p>
<p>ThreadPoolExecutor的构造函数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;= 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        this.workQueue = workQueue;</span><br><span class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ol>
<li><p>corePoolSize核心线程数大小，当线程数 &lt; corePoolSize，会创建线程执行runnable</p>
</li>
<li><p>maximumPoolSize最大线程数，当线程数 &gt;= corePoolSize的时候，会把runnable房屋workQueue中</p>
</li>
<li><p>keepAliveTime保持存活时间，当线程数 &gt; corePoolSize的空闲线程能保持的最大时间。</p>
</li>
<li><p>unit 时间单位</p>
</li>
<li><p>workQueue保存任务的阻塞队列</p>
</li>
<li><p>threadFactory 创建线程的工厂</p>
</li>
<li><p>handler 拒绝策略</p>
</li>
</ol>
<p>任务执行顺序：</p>
<ol>
<li><p>当线程数小于 corePoolSize，创建线程执行任务</p>
</li>
<li><p>当线程数大于等于 corePoolSize 并且workQueue没有满时，放入workQueue中</p>
</li>
<li><p>当线程数大于等于 corePoolSize并且当workQueue满时，新任务新建线程运行，线程总数要小于maximumPoolSize</p>
</li>
<li><p>当线程总数等于maximumPoolSize并且workQueue满了的时候执行handler的rejectedExecutor。也就是拒绝策略</p>
</li>
</ol>
<p>ThreadPoolExecutor默认有四个拒绝策略：</p>
<ol>
<li><p>ThreadPoolExecutor.AbortPolicy() 直接抛出异常，RejectedExecutionException</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy()直接调用run方法并阻塞执行</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy()直接丢弃后来的任务</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务</p>
</li>
</ol>
<p>当然可以自己继承RejectedExecutionHandler来写拒绝策略</p>
<p>参考来源：<a href="https://juejin.im/post/5aae4e8f6fb9a028e52d9e8c" target="_blank" rel="noopener">https://juejin.im/post/5aae4e8f6fb9a028e52d9e8c</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/03/reflection/" rel="next" title="Java 反射">
                <i class="fa fa-chevron-left"></i> Java 反射
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">choleece</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是线程？"><span class="nav-number">1.</span> <span class="nav-text">1. 什么是线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-什么是线程安全和线程不安全？"><span class="nav-number">2.</span> <span class="nav-text">2. 什么是线程安全和线程不安全？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全"><span class="nav-number">2.1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程不安全"><span class="nav-number">2.2.</span> <span class="nav-text">线程不安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-什么是自旋锁？"><span class="nav-number">3.</span> <span class="nav-text">3. 什么是自旋锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自旋锁需要注意："><span class="nav-number">3.1.</span> <span class="nav-text">自旋锁需要注意：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-什么是Java内存模型？"><span class="nav-number">4.</span> <span class="nav-text">4. 什么是Java内存模型？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java的JVM的内存可分为3个区：堆（heap）、栈-stack-和方法区（method）"><span class="nav-number">4.1.</span> <span class="nav-text">Java的JVM的内存可分为3个区：堆（heap）、栈(stack)和方法区（method）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。"><span class="nav-number">4.1.1.</span> <span class="nav-text">据Java虚拟机规范规定，当方法区取法满足内存分配需求时，将抛出OutOfMemoryError异常。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是CAS？"><span class="nav-number">5.</span> <span class="nav-text">什么是CAS？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS应用"><span class="nav-number">5.1.</span> <span class="nav-text">CAS应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS优点"><span class="nav-number">5.2.</span> <span class="nav-text">CAS优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS缺点"><span class="nav-number">5.3.</span> <span class="nav-text">CAS缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">5.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-什么是乐观锁和悲观锁？"><span class="nav-number">6.</span> <span class="nav-text">6. 什么是乐观锁和悲观锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#悲观锁"><span class="nav-number">6.1.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#乐观锁"><span class="nav-number">6.2.</span> <span class="nav-text">乐观锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-什么是原子操作？在Java-Concurrency-API中有哪些原子类（atomic-classes）？"><span class="nav-number">7.</span> <span class="nav-text">6. 什么是原子操作？在Java Concurrency API中有哪些原子类（atomic classes）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-什么是Executors框架？"><span class="nav-number">8.</span> <span class="nav-text">7. 什么是Executors框架？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><span class="nav-number">9.</span> <span class="nav-text">8.什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是阻塞队列？"><span class="nav-number">9.1.</span> <span class="nav-text">什么是阻塞队列？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者"><span class="nav-number">9.2.</span> <span class="nav-text">生产者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-什么是Callable和Future？"><span class="nav-number">10.</span> <span class="nav-text">9. 什么是Callable和Future？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-什么是FutureTask"><span class="nav-number">11.</span> <span class="nav-text">10. 什么是FutureTask?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-什么是同步容器和并发容器的实现？"><span class="nav-number">12.</span> <span class="nav-text">11. 什么是同步容器和并发容器的实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-什么是多线程？优缺点？"><span class="nav-number">13.</span> <span class="nav-text">12. 什么是多线程？优缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-什么是多线程的上下文切换？"><span class="nav-number">14.</span> <span class="nav-text">13. 什么是多线程的上下文切换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-ThreadLocal的设计理念和作用？"><span class="nav-number">15.</span> <span class="nav-text">14. ThreadLocal的设计理念和作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-ThreadPool-线程池-用法与优势？"><span class="nav-number">16.</span> <span class="nav-text">15. ThreadPool(线程池)用法与优势？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">choleece</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
